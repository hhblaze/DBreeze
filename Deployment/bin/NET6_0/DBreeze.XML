<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DBreeze</name>
    </assembly>
    <members>
        <member name="T:DBreeze.DataStructures.DataAsTree">
            <summary>
            Ierarchical DataStructure. Any node can have subnodes and own binary content
            </summary>
        </member>
        <member name="F:DBreeze.DataStructures.DataAsTree.NodeName">
            <summary>
            Node name
            </summary>
        </member>
        <member name="F:DBreeze.DataStructures.DataAsTree.NodeContent">
            <summary>
            This can be filled via constructor or extra when we insert a node
            </summary>
        </member>
        <member name="F:DBreeze.DataStructures.DataAsTree.ContentRef">
            <summary>
            Internal. Holds reference to DataBlock representing Content. node.GetContent must be used to read out content.
            </summary>
        </member>
        <member name="F:DBreeze.DataStructures.DataAsTree.DBreezeTableName">
            <summary>
            Real table name in DBreeze, that will hold the structure
            </summary>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.#ctor(System.String,DBreeze.Transactions.Transaction,System.Boolean)">
            <summary>
            Initializing Root Node
            </summary>
            <param name="DBreezeTableName">Real table name in DBreeze, that will hold the structure, must be synchronized with other tables in transaction</param>
            <param name="tran"></param>
            <param name="maximalInsertSpeed">will use DBreeze Technical_SetTable_OverwriteIsNotAllowed among transaction for DBreezeTableName</param>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.#ctor(System.String,System.Byte[])">
            <summary>
            Init nodes for insert under another node
            </summary>
            <param name="name"></param>
            <param name="content">optionaly can supply NodeContent</param>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.#ctor">
            <summary>
            Internal
            </summary>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.CopyInternals(DBreeze.DataStructures.DataAsTree)">
            <summary>
            Internal
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.SetupReadTables">
            <summary>
            Internal
            </summary>
            <param name="tran"></param>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.SetupWriteTables">
            <summary>
            Internal
            </summary>
            <param name="tran"></param>
            <param name="maximalSpeed"></param>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.CheckTransaction">
            <summary>
            Internal
            </summary>
            <param name="tran"></param>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.GetNodeByParentIdAndNodeId(System.Int64,System.Int64)">
            <summary>
            Returns node by ParentIdAndNodeId
            </summary>
            <param name="parentNodeId"></param>
            <param name="nodeId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.GetNodesByName(System.String)">
            <summary>
            Returns nodes with suppled StartsWith name or complete name
            </summary>
            <param name="nameStartsWithPart"></param>
            <param name="tran"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.GetFirstLevelChildrenNodesByParentId(System.Int64)">
            <summary>
            Returns first level nodes by their parent. To go depper, for every returned node can be used ReadOutAllChildrenNodesFromCurrentRecursively
            </summary>
            <param name="parentId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.SetupValueRowFromNode(DBreeze.DataStructures.DataAsTree,System.Byte)">
            <summary>
            Internal
            </summary>
            <param name="node"></param>
            <param name="protocolVersion"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.SetupNodeFromRow(DBreeze.DataTypes.Row{System.Byte[],System.Byte[]})">
            <summary>
            Internal
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.GetChildren">
            <summary>
            Reading all children nodes
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.RemoveNode(System.Int64,System.Int64)">
            <summary>
            Removes node
            </summary>
            <param name="parentNodeId"></param>
            <param name="nodeId"></param>
            <param name="tran"></param>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.RemoveNode(DBreeze.DataStructures.DataAsTree)">
            <summary>
             Removes node
            </summary>
            <param name="node"></param>
            <param name="tran"></param>
            <param name="maximalSpeed"></param>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.AddNodes(System.Collections.Generic.IEnumerable{DBreeze.DataStructures.DataAsTree})">
            <summary>
            <para>Adding children to the node</para>
            Table, storing data structure, must be in tran.SynchronizeTables list.
            Then transaction must be Committed in the end by the programmer.
            </summary>
            <param name="nodes">Nodes to add to current node</param>
            <param name="tran">Existing transaction. Table, storing data structure, must be in tran.SynchronizeTables list</param>
            <param name="maximalSpeed">set it to true to gain maximal saving speed</param>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.RemoveOldNodeFromNameIndex(System.String,System.Byte[])">
            <summary>
            Internal
            </summary>
            <param name="nameIndexRow"></param>
            <param name="keyToRemove"></param>
            <returns>new nameIndexRow</returns>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.AddNode(DBreeze.DataStructures.DataAsTree)">
            <summary>
            <para>Adding children to the node</para>
            Table, storing data structure, must be in tran.SynchronizeTables list.
            Then transaction must be Committed in the end by the programmer.
            </summary>
            <param name="nodes">Nodes to add to current node</param>
            <param name="tran">Existing transaction. Table, storing data structure, must be in tran.SynchronizeTables list</param>
            <param name="maximalSpeed">set it to true to gain maximal saving speed</param>
            <returns>return node with setup parent id</returns>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.GetContent">
            <summary>
            GetContent of a node, 
            </summary>
            <returns>null if content is absent</returns>
        </member>
        <member name="M:DBreeze.DataStructures.DataAsTree.ReadOutAllChildrenNodesFromCurrentRecursively">
            <summary>
            Recursively reads out all children nodes starting from this recursiverly
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.DataTypesConvertor.ConvertValue``1(``0)">
            <summary>
            Converts type to a byte[] 
            </summary>
            <typeparam name="TData"></typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.DataTypesConvertor.ConvertKey``1(``0)">
            <summary>
            Converts key type to a byte[] 
            </summary>
            <typeparam name="TData"></typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.DataTypesConvertor.ConvertBack``1(System.Byte[])">
            <summary>
            CONVERTING FROM byte[] to the generic type
            </summary>
            <typeparam name="TData"></typeparam>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.DataTypes.DbAscii">
            <summary>
            String.Empty is will return NULL
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbAscii.Get">
            <summary>
            Returns string from the object
            </summary>
        </member>
        <member name="T:DBreeze.DataTypes.DbCustomSerializer`1">
            <summary>
            <para>Custom Serializer</para>
            <para></para>
            <para>To support JSON.NET, make a reference to their library and then somewhere before engine init add 2 lines:</para>
            <para>CustomSerializator.Serializator = JsonConvert.SerializeObject;</para>
            <para>CustomSerializator.Deserializator = JsonConvert.DeserializeObject;</para>
            <para></para>
            <para>Possible to make like this, without class instantiating:</para>
            <para>List&lt;string&gt; aa = new List&lt;string&gt;();</para>
            <para>aa.Add("test1")</para>
            <para>aa.Add("test2")</para>
            <para>-----inside of transaction---------</para>
            <para>tran.Insert&lt;uint, DbCustomSerializer&lt;List&lt;string&gt;&gt; &gt;("t1", i, aa);</para>
            <para>-----------------------------------</para>
            <para>foreach (var row in tran.SelectForward&lt;uint, DbCustomSerializer&lt;List&lt;string&gt;&gt; &gt;("t1"))</para>
            <para>Console.WriteLine("K: {0}; V: {1}", row.Key.ToString(), (row.Value == null) ? "NULL" : row.Value.Get.Count().ToString());</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DBreeze.DataTypes.DbCustomSerializer`1.SerializedObject">
            <summary>
            Returns serialized string representing the internal object
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbCustomSerializer`1.Get">
            <summary>
            Gets deserialized object
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbUnicode.Get">
            <summary>
            Returns string from the object
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbUTF8.Get">
            <summary>
            Returns string from the object
            </summary>
        </member>
        <member name="T:DBreeze.DataTypes.Row`2">
            <summary>
            Row
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.TableName">
            <summary>
            Default null. Returns table name this row belongs to in case of Multi_SelectForward etc requests
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.Exists">
            <summary>
            Exists
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.Key">
            <summary>
            Key
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetTable(System.UInt32)">
            <summary>
            We are inside of the row.
            <para>This Method will give you ability to the nested tables which can be stored inside of table by tableIndex</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetValuePart(System.UInt32,System.UInt32)">
            <summary>
            Returns partial value representation starting from specif index and specified length.
            <para>To get full value as byte[] use GetValuePart(0)</para>
            </summary>
            <param name="startIndex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetValuePart(System.UInt32)">
            <summary>
            Returns partial value representation starting from specif index till and till the end of value.
            </summary>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.LinkToValue">
            <summary>
            Returns physical link to key/value if it exists, otherwise null,
            this link can be used by SelectDirect (always returns 8 bytes)
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetDataBlock(System.UInt32)">
            <summary>
            Insert dynamic length datablock is possible via tran.InsertDataBlock or NestedTable.InsertDataBlock.
            <para></para>
            can return null.
            </summary>
            <param name="startIndex"></param>
            <returns>Returns datablock which identifier is stored in this row from specified index.</returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetDataBlockWithFixedAddress``1(System.UInt32)">
            <summary>
            Returns datablock which fixed address, which identifier is stored in this row from specified index.
            </summary>
            <typeparam name="TVal"></typeparam>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.ObjectGet``1">
            <summary>
            Concept of the objects storage (read docu from 20170321)
            Get object from a datablock with a fixed address, 
            having that the pointer to the object (16 byte) is saved from the startIndex inside of a row's value.  
            Returns null if object is not found.
            </summary>
            <typeparam name="TVal"></typeparam>
            <returns></returns>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.Value">
            <summary>
            Returns full value and converts it to the value data type.
            <para>To take full value or part of the value as byte[] use GetValuePart or GetBytes (for string types like DbAscii etc.)</para>
            <para>If your value contains serialized object inside or it's a string type (like DbAscii etc.), use Value.Get property.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.PrintOut(System.String)">
            <summary>
            Experimantal Console PrintOut
            </summary>
        </member>
        <member name="T:DBreeze.DataTypes.NestedTable">
            <summary>
            NestedTable
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.#ctor(DBreeze.DataTypes.NestedTableInternal,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="nt"></param>
            <param name="insertTablesAllowed"></param>
            <param name="tableExists"></param>
        </member>
        <member name="P:DBreeze.DataTypes.NestedTable.ValuesLazyLoadingIsOn">
            <summary>
            When it's on iterators return Row with the key and a pointer to the value.
            <par>Value will be read out when we call it Row.Value.</par>
            <pa>When it's off we read value together with the key in one round</pa>
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.GetTable``1(``0,System.UInt32)">
            <summary>
            You are already in the table
            <para>This function will help to access another table by parent table key and its value index</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.CloseTable">
            <summary>
            Tries to close the table if no other threads are using it.
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertDataBlock(System.Byte[],System.Byte[])">
            <summary>
            Insert a dynamic size data block in the table storage, returns fixed 16 bytes length identifier
            <para></para>
            which can be stored in a table value from specified index.
            <para></para>
            Retrieve such DataBlock we can using Row.GetDataBlock.
            <para>The same statement is used to update datablock, received value must update row value who holds reference to it.</para>
            <para>Must be used as row column with dynamic length</para>
            </summary>
            <param name="initialPointer">if null creates new data block, if not null tries to overwrite existing data block</param>
            <param name="data"></param>
            <returns>returns created data block parameters of fixed 16 bytes length, which can be stored in the row value
            <para>and later reused for getting data block back</para>
            </returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDataBlock(System.Byte[])">
            <summary>
            Another way (second is via row by index where pointer is stored) to get stored data block
            </summary>
            <param name="initialPointer"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1,System.Byte[]@)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1,System.Byte[]@,System.Boolean@)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1,System.Byte[]@,System.Boolean@,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <param name="dontUpdateIfExists">When true - if value exists, we dont update it. If WasUpdated = true then value exists, if false - we have inserted new one</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Technical_SetTable_OverwriteIsNotAllowed">
            <summary>
            <para>After the end of transaction overwrite will be allowed again.</para>
            <para>Concerns overwriting of values, trie search nodes and dataBlocks.</para>
            <para>ref. documentation from [20130412]</para>
            </summary>
            <param name="isAllowed"></param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertDictionary``3(``0,System.Collections.Generic.Dictionary{``1,``2},System.UInt32,System.Boolean)">
            <summary>
            Inserts a dictionary into nested-table row.
            <para></para>
            Designed for simple dictionary data types.
            <para></para>
            Actually creates a new table inside of nested table row and handles it like dictionary.
            <para></para>
            If new Dictionary is supplied then non-existing keys in supplied DB will be removed from db
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get dictionary use SelectDictionary</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
            <returns>Returns Nested Table where insert was made</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertDictionary``2(System.Collections.Generic.Dictionary{``0,``1},System.Boolean)">
            <summary>
            Inserts dictionary into current nested table.
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
            <returns>current nested table</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDictionary``3(``0,System.UInt32)">
            <summary>
            Selects complete table from nested-table row nested table, by row nested-table index as Dictionary.
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDictionary``2">
            <summary>
            Selects completely current nested-table as a Dictionary.
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertHashSet``2(``0,System.Collections.Generic.HashSet{``1},System.UInt32,System.Boolean)">
            <summary>
            Inserts a HashSet (unique list of Keys) into nested-table row.
            <para></para>
            Actually creates a new table inside of nested table row and handles it like table with THashSetKey key any byte[] == null value.
            <para></para>
            If new HashSet is supplied then non-existing keys in supplied DB will be removed from db (withValuesRemove=true)
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get HashSet use SelectHashSet</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
            <returns>Returns Nested Table where insert was made</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertHashSet``1(System.Collections.Generic.HashSet{``0},System.Boolean)">
            <summary>
            Inserts HashSet into current nested-table
            </summary>
            <typeparam name="THashSetKey"></typeparam>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
            <returns>current nested table</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectHashSet``2(``0,System.UInt32)">
            <summary>
            Selects complete table from nested-table row nested table, by row nested-table index as HashSet (unique list of Keys).
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns>HashSet</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectHashSet``1">
            <summary>
            Returns completely current nested-table as a HashSet (unique list of Keys).
            </summary>
            <typeparam name="THashSetKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertPart``2(``0,``1,System.UInt32)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para> 
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertPart``2(``0,``1,System.UInt32,System.Byte[]@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para> 
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertPart``2(``0,``1,System.UInt32,System.Byte[]@,System.Boolean@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para> 
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Select``2(``0)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.DataTypes.NestedTable.readRootNode">
            <summary>
            TO be used in Select with ReadVisibilityScope as True. Is created only once per instantiated nested table. 
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Select``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, select will return key/value,</para>
            <para>like it was before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDirect``2(System.Byte[])">
            <summary>
            <para>EXPERIMENTAL</para>
            Returns Row by supplying direct pointer to key/value in the file.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="refToInsertedValue"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveAllKeys">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveKey``1(``0)">
            <summary>
            Removes a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveKey``1(``0,System.Boolean@)">
            <summary>
            Removes a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system</param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveKey``1(``0,System.Boolean@,System.Byte[]@)">
            <summary>
            Removes a key
            </summary>
            <typeparam name="TKey">type of the key</typeparam>
            <param name="key">key to delete</param>
            <param name="WasRemoved">indicates that key existed in the system</param>
            <param name="deletedValue">Will hold deleted value if WasRemoved is true</param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveKey``1(``0,System.Boolean@,System.Boolean,System.Byte[]@)">
            <summary>
            Removes a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system</param>
            <param name="retrieveDeletedValue">indicates if system should retrieve deleted value</param>
            <param name="deletedValue"></param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.ChangeKey``1(``0,``0)">
            <summary>
            Renames old key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="oldKey"></param>
            <param name="newKey"></param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.ChangeKey``1(``0,``0,System.Byte[]@)">
            <summary>
            Renames old key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.ChangeKey``1(``0,``0,System.Byte[]@,System.Boolean@)">
            <summary>
            Renames old key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
            <param name="WasChanged">indicates that oldKey existed and was succesfully changed</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Count">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Max``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Min``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForward``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForward``2(System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackward``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackward``2(System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartFrom``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartFrom``2(``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartFrom``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartFrom``2(``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardFromTo``2(``0,System.Boolean,``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardFromTo``2(``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardFromTo``2(``0,System.Boolean,``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardFromTo``2(``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWith``2(``0)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWith``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWithClosestToPrefix``2(``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWithClosestToPrefix``2(``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWithClosestToPrefix``2(``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWithClosestToPrefix``2(``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWith``2(``0)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWith``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkip``2(System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkip``2(System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkip``2(System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkip``2(System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkipFrom``2(``0,System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkipFrom``2(``0,System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkipFrom``2(``0,System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkipFrom``2(``0,System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.DataTypes.NestedTableInternal">
            <summary>
            In developing, will represent a table inside of the other table
            </summary>
        </member>
        <member name="F:DBreeze.DataTypes.NestedTableInternal.TableExists">
            <summary>
            Identifies that table is fake, because we always want to return data even default (count - 0, select - row with .Exists= false etc...)
            </summary>
        </member>
        <member name="F:DBreeze.Diagnostic.SpeedStatistic.ToConsole">
            <summary>
            Default is Debug.WriteLine, can be changed to Console.WriteLine
            </summary>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.StartCounter(System.String)">
            <summary>
            Starts counter
            </summary>
            <param name="counterName"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.StopCounter(System.String)">
            <summary>
            Stops counter
            </summary>
            <param name="counterName"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.GetCounter(System.String)">
            <summary>
            Returns Counter object.
            Can return NULL if counter not found
            </summary>
            <param name="counterName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut">
            <summary>
            Prints out stat for all counters without clearing statistic 
            </summary>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut(System.String)">
            <summary>
            Prints out counter without clearing statistic for this counter
            </summary>
            <param name="counterName"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut(System.String,System.Boolean)">
            <summary>
            Prints out specified counter.
            </summary>
            <param name="counterName"></param>
            <param name="withClearingCounter"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut(System.Boolean)">
            <summary>
            Prints out stats for all counters
            </summary>
            <param name="withResetingStatistic">resets statistic</param>
        </member>
        <member name="T:DBreeze.DBreezeEngine">
            <summary>
            Main DBreeze Database class.
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeEngine.MainFolder">
            <summary>
            DBreeze version number
            </summary>        
        </member>
        <member name="F:DBreeze.DBreezeEngine.Resources">
            <summary>
            DBreeze resources represents an In-Memory dictionary synchronized with an internal DBreeze table. 
            Key is a string, Value any standard DBreeze.DataType (or serialized object by supplied serializer).
            Can be called from anywhere, even from other transactions. There is no need to add into sync table
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeEngine.DBisOperable">
            <summary>
            Db is not operable any more by DBisOperableReason reason 
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeEngine.DBisOperableReason">
            <summary>
            Is filled with a text note who brought to DBisOperable = false
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeEngine.Disposed">
            <summary>
            Whether engine is disposed
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeEngine.RemoteEngine">
            <summary>
            Initialized from DBreezeRemoteEngine
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeEngine.BackgroundTasksExternalNotifier">
            <summary>
            DBreeze may execute some tasks in the background (like deffered text indexing). 
            External delegate can receive notifications about that.
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeEngine.Configuration">
            <summary>
            Dbreeze Configuration.
            For now BackupPlan is included.
            Later can be added special settings for each entity defined by string pattern.
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeEngine.#ctor">
            <summary>
            For DbreezeRemoteEngine wrapper
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeEngine.#ctor(DBreeze.DBreezeConfiguration)">
            <summary>
            Dbreeze instantiator
            </summary>
            <param name="dbreezeConfiguration"></param>
        </member>
        <member name="M:DBreeze.DBreezeEngine.ConstructFromConfiguration(DBreeze.DBreezeConfiguration)">
            <summary>
            Constructing Dbreeze from dbreezeConfiguration
            </summary>
            <param name="dbreezeConfiguration"></param>
        </member>
        <member name="M:DBreeze.DBreezeEngine.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="DBreezeDataFolderName"></param>
        </member>
        <member name="M:DBreeze.DBreezeEngine.InitDb">
            <summary>
            InitDb
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeEngine.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeEngine.GetTransaction">
            <summary>
            Returns transaction object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DBreezeEngine.GetTransaction(DBreeze.eTransactionTablesLockTypes,System.String[])">
            <summary>
            Returns transaction object.
            </summary>
            <param name="tablesLockType">
            <para>SHARED: threads can use listed tables in parallel. Must be used together with tran.SynchronizeTables command, if necessary.</para>
            <para>EXCLUSIVE: if other threads use listed tables for reading or writing, current thread will be in a waiting queue.</para>
            </param>
            <param name="tables"></param>
            <returns>Returns transaction object</returns>
        </member>
        <member name="P:DBreeze.DBreezeEngine.Scheme">
            <summary>
            Returns DBreeze schema object
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeEngine.BackgroundNotify(System.String,System.Object)">
            <summary>
            Notifier about background events.
            </summary>
            <param name="noti"></param>
            <param name="obj"></param>
        </member>
        <member name="T:DBreeze.DBreezeRemoteEngine">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeRemoteEngine.#ctor(DBreeze.DBreezeConfiguration)">
            <summary>
            DBreezeRemoteEngine instantiator
            </summary>
            <param name="dbreezeConfiguration"></param>
        </member>
        <member name="M:DBreeze.DBreezeRemoteEngine.Init">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeRemoteEngine.GetTransaction">
            <summary>
            Returns transaction object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DBreezeRemoteEngine.GetTransaction(DBreeze.eTransactionTablesLockTypes,System.String[])">
            <summary>
            Returns transaction object.
            </summary>
            <param name="tablesLockType">
            <para>SHARED: threads can use listed tables in parallel. Must be used together with tran.SynchronizeTables command, if necessary.</para>
            <para>EXCLUSIVE: if other threads use listed tables for reading or writing, current thread will be in a waiting queue.</para>
            </param>
            <param name="tables"></param>
            <returns>Returns transaction object</returns>
        </member>
        <member name="P:DBreeze.DBreezeRemoteEngine.Scheme">
            <summary>
            Returns DBreeze schema object
            </summary>
        </member>
        <member name="T:DBreeze.Exceptions.TableNotOperableException">
            <summary>
            This is a specific Exception which will bring to DB is not opearable state, we need to analyze this type of exception separately,
            that's why extra class.
            </summary>
        </member>
        <member name="T:DBreeze.Exceptions.DBreezeException">
            <summary>
            Unified class for Debreeze exceptions
            </summary>
        </member>
        <member name="F:DBreeze.Exceptions.DBreezeException.eDBreezeExceptions.DBREEZE_RESOURCES_CONCERNING">
            <summary>
            The rest must be supplied via extra params
            </summary>
        </member>
        <member name="M:DBreeze.Exceptions.DBreezeException.GenerateException(DBreeze.Exceptions.DBreezeException.eDBreezeExceptions,System.String,System.Exception)">
            <summary>
            Internal
            </summary>
            <param name="exceptionType"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationMap.GenerateMapNodesValuesUpToIndex(System.Int32,System.Boolean)">
            <summary>
            Used for finding out hash from Generation Map
            </summary>
            <param name="index"></param>
            <param name="forceGenerateMapUpToIndex"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.QuantityReservationSlots">
            <summary>
            Reservations are calculated by Schema. They Depend upon quantity of Existing Kids.
            QuantityAvailableReservations is calculated in ReadSelf if Kid.Pointer equals to ZeroPointer - it means reservation.
            Default is 0
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.ToChangeParentNode">
            <summary>
            When New Node is created it's true
            After Reading Node it must become false,
            After WriteSelf it will be or true or false.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.KidsBeforeModification">
            <summary>
            Field which contains either null (if Generation node is empty and had no kids) or value in format of prepared for Save Kids,
            in case if ReadOutExistingNode.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.MaximumKidLineLength">
            <summary>
            Is calculated as LengthOfTheKidsBlockInFile(2 bytes) + (256 * (DefaultPointerLen + 1[byte definition]))
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.SetupKidWithValue(System.Byte,System.Boolean,System.Byte[]@,System.Byte[]@,System.Boolean,System.Boolean@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="kid"></param>
            <param name="lastElementOfTheKey"></param>
            <param name="fullKey"></param>
            <param name="value"></param>
            <param name="useExistingPointerToValue"></param>
            <param name="WasUpdated">true means that value existed and was updated</param>
            <param name="dontUpdateIfExists">When true - if value exists, we dont update it. If WasUpdated = true then we value exists, if false - we have inserted new one</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.RemoveKid(System.Byte,System.Boolean,System.Byte[]@,System.Boolean@,System.Boolean,System.Byte[]@)">
            <summary>
            Pointer to the removing key value can be null, if such key never existed
            </summary>
            <param name="kid"></param>
            <param name="lastElementOfTheKey"></param>
            <param name="key"></param>
            <param name="ptrToValue"></param>
            <param name="WasRemoved">indicates that value existed if true</param>
            <param name="retrieveDeletedValue">indicates if we must also return deleted value</param>
            <param name="WasRemoved">deleted value as byte[] will be here</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.TryOverWriteValuePartially(System.Byte[],System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@)">
            <summary>
            Returns pointer to the newly stored value
            </summary>
            <param name="ptr"></param>
            <param name="value"></param>
            <param name="fullKey"></param>
            <param name="startIndex">from which point we should overwrite value</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.TryOverWriteValue(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Returns pointer to the newly stored value
            </summary>
            <param name="ptr"></param>
            <param name="value"></param>
            <param name="fullKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.GetQuantityOfReservationSlots">
            <summary>
            Calculating Quantity of Reservations slots for 0 and 1 Evolutions.
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.Val">
            <summary>
            0-255, in case if ValueKid = false, 256 if ValueKid = true;
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.Ptr">
            <summary>
            Pointer to the next node or to the value
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.Exists">
            <summary>
            Default value is false
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.LinkToNode">
            <summary>
            Works when ValueKid = false.
            True is link to node
            False if link to value.
            Default is true.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.ValueKid">
            <summary>
            Identifies that it's a value for this node, not the kid from 0-255.
            If true, Ptr has link to the value.
            Default is false
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKidsInNode.ValueIsEmpty">
            <summary>
            Indicates that Kids Line contains no Value-Kid
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKidsInNode.AllowSave">
            <summary>
            Optimizer. We don't want to overwrite node, if really nothing has changed. In the beginning value is true.
            ParseKids function make it false.
            Later by Adding or removing elements we either make it true or leave as false.
            search in the code  (!AllowSave).
            The flag work result is visible in GetKidsForSave function.
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieKidsInNode.ParseKids(System.Byte[]@)">
            <summary>
            Returns quantity of reservation slots
            </summary>
            <param name="bKids"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieKidsInNode.GetKidValue">
            <summary>
            Gets Value kid (before 0-255)
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieKidsInNode.GetKidsForSave(System.Int32)">
            <summary>
            Returns null, if not necessary to save generation node (cause it didn't change).  AllowSave = false;
            </summary>
            <param name="reservation"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRow.ValueStartPointer">
            <summary>
            Represents pointer to the value in physical file, remember for READ must come via sync-cache
            -1 if not defined
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRow.ValueFullLength">
            <summary>
            If ValueStartPointer == -1, has no meaning
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRow.Key">
            <summary>
            Default is null
            </summary>
        </member>
        <member name="P:DBreeze.LianaTrie.LTrieRow.LinkToValue">
            <summary>
            Experimental, instead of Value, we supply link to the value
            </summary>
        </member>
        <member name="P:DBreeze.LianaTrie.LTrieRow.Exists">
            <summary>
            Default is false
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRow.GetPartialValue(System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Returns either value partially or null
            </summary>
            <param name="startIndex"></param>
            <param name="length"></param>
            <param name="useCache">if true, then only committed data will be shown</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRow.GetFullValue(System.Boolean)">
            <summary>
            Returns either value as byte array or null if value doesn't exist
            </summary>
            <param name="useCache">if true, then only committed data will be shown</param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieSetupKidResult.ValueLink">
            <summary>
            Link to the full value line (together with the key)
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieWriteCache.rootTransaction">
            <summary>
            Represents old Root as byte[] array for the moment while we make Transactional Commit. Otherwise remains null
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.RootNodeWrite(System.Byte[])">
            <summary>
            
            </summary>
            <param name="rootData"></param>
            <param name="oldRootData"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.RootNodeRead">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.Commit(System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="rootData"></param>
            <param name="oldRootData"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.RollBack">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.TransactionalCommit(System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="rootData"></param>
            <param name="oldRootData"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.TransactionalCommitFinished">
            <summary>
            We need here to clear old root and call Storage Commit is finished
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.TransactionalRollBack">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.RecreateDB">
            <summary>
            Used by Root Node RemoveAll with key re-creation
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GetNodeKids(System.Byte[])">
            <summary>
            Returns NULL if not found
            </summary>
            <param name="generationMapLine"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GenerationNodeWritingEnd(System.Byte[],System.Byte[])">
            <summary>
            Writing Generation Node to the end of File.
            We use current generation node pointer to black list it.
            if we reuse this new pointer inside of one transaction for overwriting, we don't need to back it up for rollback any more.
            </summary>
            <param name="pointer"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GenerationNodeWritingOver(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            OverWriting Generation Node, we supply params where, oldData and newData.
            </summary>
            <param name="pointer"></param>
            <param name="newData"></param>
            <param name="generationMapLine"></param>
            <param name="kidsBeforeModification"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GenerationNodeRead(System.Boolean,System.Byte[],System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache"></param>
            <param name="pointer"></param>
            <param name="cachedGenerationMapLine"></param>
            <param name="MaximumNodeLineLength"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadDynamicDataBlock(System.Byte[]@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="initPtr"></param>
            <param name="useCache"></param>
            <returns>return NULL if not found or stored value is NULL, otherwise returns byte[]</returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.WriteDynamicDataBlock(System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="initPtr"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ValueWritingEnd(System.Byte[]@,System.Byte[])">
            <summary>
             
            </summary>
            <param name="data"></param>
            <param name="oldPtr"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ValueWritingOver(System.Byte[],System.Byte[]@,System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="pointer"></param>
            <param name="oldData"></param>
            <param name="newData"></param>
            <param name="key"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadKeyValue(System.Boolean,System.Byte[],System.Int64@,System.UInt32@,System.Byte[]@,System.Byte[]@)">
            <summary>
            Interanl Function for reading Key and Value in one set. Initial block read is setUp to 4096 bytes
            </summary>
            <param name="useCache"></param>
            <param name="pointer">ptr to KVP</param>
            <param name="valueStartPtr">will be more then 0 only in case if valueLength more then 0. It makes no diff for the null and byte[0] values in this context. Avoid byte[0]</param>
            <param name="valueLength">will be 0 if val is null and if val is byte[0]</param>
            <param name="key"></param>
            <param name="val"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadKey(System.Boolean,System.Byte[])">
            <summary>
            Internal function for reading key only from DB storage
            Is called from ReadKey
            </summary>
            <param name="useCache"></param>
            <param name="pointer">ptr to KVP</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadValue(System.Byte[],System.Boolean,System.Int64@,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="pointer">ptr to KVP</param>
            <param name="useCache"></param>
            <param name="valueStartPtr"></param>
            <param name="valueLength"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadValuePartially(System.Byte[],System.UInt32,System.UInt32,System.Boolean,System.Int64@,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="pointer"></param>
            <param name="startIndex"></param>
            <param name="length"></param>
            <param name="useCache"></param>
            <param name="valueStartPtr">returns pointer where value starts from. -1 if can't be determined</param>
            <param name="valueLength">returns full value length; 0 - default</param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.LianaTrie.NestedTablesCoordinator">
            <summary>
            Represents a bound to the LTrie nested tables coordinator.
            1. Gets ability to remember Inserted Tables to perform cascade commit.
            2. Rebind internal root-start if 2 or more horizontal tables are inserted into 1 value during one transaction (value expand case)
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.NestedTablesCoordinator._nestedTables">
            <summary>
            Key is a pointer to the full value, then in the value new Dictionary
            where key is root_start
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.NestedTablesCoordinator.ModificationThreadId">
            <summary>
            Will be taken into consideration only from MasterTrie.
            Set up to -1 after Commit and Rollback, Set To Thread id when tran.InsertTable is called
            using this flag we will be able to regulate returns (based on useCache or not for nested Tables)
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.AddNestedTable(System.Byte[]@,System.UInt64,System.Int64,DBreeze.DataTypes.NestedTableInternal)">
            <summary>
            LTrie makes in case of InsertTable call
            </summary>
            <param name="nestedTable"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.TransactionalCommitFinished">
            <summary>
            Committing nested tables
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.Commit">
            <summary>
            Committing nested tables
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.TransactionalCommit">
            <summary>
            Transactional Commit Nested
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.TransactionalRollback">
            <summary>
            Transactional Rollback nested
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.GetTable(System.Byte[]@,System.Int64)">
            <summary>
            Returns null if table is not in the coordinator, otherwise returns reference to the table
            </summary>
            <param name="fullValueStart"></param>
            <param name="rootStart"></param>
            <returns></returns>      
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.Remove(System.Byte[]@)">
            <summary>
            Cascade remove all of all nested and sub-nested tables under the key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTableStorage.RestoreTableFromTheOtherTable(System.String)">
            <summary>
            Works only for master tables
            </summary>
            <param name="newTableFullPath"></param>
        </member>
        <member name="F:DBreeze.LianaTrie.Iterations.Backward.ReturnKeyValuePair">
            <summary>
            If we use load Key already With Value, or just key and link to the value
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.Iterations.Backward.ItBwdFromTo(DBreeze.LianaTrie.LTrieGenerationNode,System.Byte[],System.Boolean)">
            <summary>
            ItBwdFromTo
            </summary>
            <param name="gn"></param>
            <param name="generationMapLine"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.Iterations.Backward.IterateBackwardFromTo(System.Byte[],System.Byte[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            IterateBackwardFromTo
            </summary>
            <param name="initKey"></param>
            <param name="stopKey"></param>
            <param name="inclStartKey"></param>
            <param name="inclStopKey"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.Iterations.Forward.ReturnKeyValuePair">
            <summary>
            If we use load Key already With Value, or just key and link to the value
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.Iterations.Forward.ItFrwFromTo(DBreeze.LianaTrie.LTrieGenerationNode,System.Byte[],System.Boolean)">
            <summary>
            ItFrwFromTo
            </summary>
            <param name="gn"></param>
            <param name="generationMapLine"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.Iterations.Forward.IterateForwardFromTo(System.Byte[],System.Byte[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            IterateForwardFromTo
            </summary>
            <param name="initKey"></param>
            <param name="stopKey"></param>
            <param name="inclStartKey"></param>
            <param name="inclStopKey"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.LianaTrie.LTrie">
            <summary>
            Liana Trie
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.Cache">
            <summary>
            Cache for overwriting nodes and values
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.TableIsModified">
            <summary>
            Identifies that after Saving0generationNode was made no changes (Add,Remove etc)
            Used via TableIsModified
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie._DtTableFixed">
            <summary>
            Is by Commit and Rollback only, we will use it to return correct ReadRootNodes out to the system
            Access via DtTableFixed interface ITrie
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.NestedTablesCoordinator">
            <summary>
            Coordinator of nested tables
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.OverWriteIsAllowed">
            <summary>
            Concerns Nodes, Values, DataBlocks.
            Flag can be setup only via nested table or transaction
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.#ctor(DBreeze.Storage.IStorage)">
            <summary>
            Liana Trie
            </summary>
            <param name="storage"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.CheckTableIsOperable">
            <summary>
            Will return exception, if not.
            Must be called by all functions
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.RollBack">
            <summary>
            RollBack
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetTable(DBreeze.LianaTrie.LTrieRow,System.Byte[]@,System.UInt32,DBreeze.LianaTrie.LTrie,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="row"></param>
            <param name="btKey"></param>
            <param name="tableIndex"></param>
            <param name="masterTrie"></param>
            <param name="insertTable">Regulates if InsertTable or SelectTable was called (ability to create table if it doesn't exist)</param>
            <param name="useCache">Regulates READ table thread or WRITE table thread - visibilityscope</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Add(System.Byte[],System.Byte[])">
            <summary>
            Adds key. Overload without refs
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Add(System.Byte[]@,System.Byte[]@,System.Boolean@,System.Boolean)">
            <summary>
            Adds key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <param name="dontUpdateIfExists">When true - if value exists, we dont update it. If WasUpdated = true then we value exists, if false - we have inserted new one</param>
            <returns>returns physical link to value</returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.AddPartially(System.Byte[],System.Byte[],System.UInt32,System.Int64@)">
            <summary>
            Overload without refs
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.AddPartially(System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@)">
            <summary>
            REMEMBER THAT 
            all keys are first formed in memory and then copied to the disk, so it's not for storing movies inside of the value.
            For storing movies (BLOBs) will be used other approach, see docu.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.AddPartially(System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@,System.Boolean@)">
            <summary>
            REMEMBER THAT 
            all keys are first formed in memory and then copied to the disk, so it's not for storing movies inside of the value.
            For storing movies (BLOBs) will be used other approach, see docu.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="WasUpdated"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Remove(System.Byte[]@,System.Boolean@,System.Boolean,System.Byte[]@)">
            <summary>
            Removes the key
            </summary>
            <param name="key"></param>
            <param name="WasRemoved">indicates that value existed if true</param>
            <param name="retrieveDeletedValue">indicates if we should bind deleted value to the result</param>
            <param name="deletedValue">interesting only if WasRemoved = true and retrieveDeletedValue is true</param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.SaveGenerationMap">
            <summary>
            Technical function.
            Used by Fetch SYNCHRO_READ FUNCs, which use write root node, to make last in-memory changes to flash on the disk, before commit.
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetTrieReadNode(System.Int64@)">
            <summary>
            Interface function which recreates every time new rootNode from itself by every new function call.
            and also packs root node last fixation dateTime (ROLL or COMMIT).
            It will be used for READ FUNC's via Transaction, they can decide if to create new instance of read root or use existing.
            Returns NULL is !TableIsOperable.
            </summary>
            <param name="modifiedDt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Count(System.Boolean)">
            <summary>
            if useCache = true; uses newly created root node, else uses writing root node
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Count(DBreeze.Tries.ITrieRootNode)">
            <summary>
            Can be used inside of DBreeze - concerns all read functions
            </summary>
            <param name="SYNCHRO_READ"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetKey(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
             if useCache = true; uses newly created root node, else uses writing root node
            </summary>
            <param name="key"></param>
            <param name="useCache"></param>
            <param name="ValuesLazyLoadingIsOn"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetKey(System.Byte[]@,DBreeze.Tries.ITrieRootNode,System.Boolean)">
            <summary>
            DBreeze compatible.
            Extension, which helps to READ-THREADS smartly utilize created before read-roots
            </summary>
            <param name="key"></param>
            <param name="readRootNode">if null then WRITE-ROOT NODE</param>
            <param name="ValuesLazyLoadingIsOn"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.SingleCommit">
            <summary>
            Wrapper for ITransactable
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.SingleRollback">
            <summary>
            Wrapper for ITransactable
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie._modificationThreadId">
            <summary>
            This variable becomes value more then -1 via TrasactionCoordinator, when it returns TableForWrite
            It becomes -1 after Transaction End call.
            No need of lock.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRootNode.RecordsCount">
            <summary>
            Indicates quantity of Records in the table
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.DeserializeRootNode">
            <summary>
            bytes[] to objects
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.SerializeRootNode">
            <summary>
            Root to byte[]
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.AddKey(System.Byte[]@,System.Byte[]@,System.Boolean@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="WasUpdated">true means that value existed and was updated</param>
            <param name="dontUpdateIfExists">When true - if value exists, we dont update it. If WasUpdated = true then we value exists, if false - we have inserted new one</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.AddKeyPartially(System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@,System.Boolean@)">
            <summary>
            Returns link to the full value together with the key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.RemoveAll(System.Boolean)">
            <summary>
            Check TransactionCommit in case of RemoveAll with file Recreation.
            Note if some other threads are reading parallel data, exception will be thrown in their transaction.
            It's correct.
            </summary>
            <param name="withFileRecreation"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.ChangeKey(System.Byte[]@,System.Byte[]@)">
            <summary>
            Takes value fresh no committed value row.GetFullValue(false);
            </summary>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.ChangeKey(System.Byte[]@,System.Byte[]@,System.Byte[]@)">
            <summary>
            Takes value fresh no committed value row.GetFullValue(false);
            </summary>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="refToInsertedValue">returns ptr in the file to the new key</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.RemoveKey(System.Byte[]@,System.Boolean@,System.Boolean,System.Byte[]@)">
            <summary>
            Will return pointer to the value of the removing kid (if it existed). Otherwise NULL.
            </summary>
            <param name="key"></param>
            <param name="WasRemoved">indicates that value existed if true</param>
            <param name="retrieveDeletedValue">indicates if we should bind deleted value to the result</param>
            <param name="deletedValue">interesting only if WasRemoved = true and retrieveDeletedValue is true</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.GetKey(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="useCache"></param>
            <param name="ValuesLazyLoadingIsOn">if true reads key only</param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.SchemeInternal.CachedTableNames">
            <summary>
            serves, cache of physical file names and corresponding virtual user table names
            </summary>
        </member>
        <member name="M:DBreeze.SchemeInternal.CachedTableNames.Add(System.String,System.UInt64)">
            <summary>
            
            </summary>
            <param name="userTableName"></param>
            <param name="fileName"></param>
        </member>
        <member name="M:DBreeze.SchemeInternal.CachedTableNames.Remove(System.String)">
            <summary>
            
            </summary>
            <param name="userTableName"></param>
        </member>
        <member name="M:DBreeze.SchemeInternal.CachedTableNames.GetFileName(System.String)">
            <summary>
            Returns 0, if can't find
            </summary>
            <param name="userTableName"></param>
        </member>
        <member name="F:DBreeze.SchemeInternal.OpenTable.qOpen">
            <summary>
            Quantity of open exemplars
            </summary>
        </member>
        <member name="M:DBreeze.SchemeInternal.OpenTable.Add">
            <summary>
            Inceases quantity of usage by one
            </summary>
        </member>
        <member name="M:DBreeze.SchemeInternal.OpenTable.Remove(System.UInt64)">
            <summary>
            Decreases quantity of usage by one and returns true if table can be automatically closed
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.UserTableNameIsOk(System.String)">
            <summary>
            Checks validity of the user table name
            </summary>
            <param name="tableName"></param>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.UserTablePatternIsOk(System.String)">
            <summary>
            Throws exception if smth. happened.
            Returns either original table name or cutted if * is found
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.PatternsIntersect(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.TableNamesIntersect(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Checks intersection between two lists of patterns
            </summary>
            <param name="list1"></param>
            <param name="list2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.TableNamesContains(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Checks intersection between List of patterns and one pattern
            </summary>
            <param name="list1"></param>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.TestIntersectionPatterns(System.Boolean,System.String,System.String)">
            <summary>
            TEST Intersections pattern
            </summary>
            <param name="assumption">your assumption, if intersects or not</param>
            <param name="p1">pattern 1</param>
            <param name="p2">pattern 2</param>
        </member>
        <member name="M:DBreeze.Storage.Backup.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="backupFolderName">Folder where will be restored incremental backup</param>
        </member>
        <member name="P:DBreeze.Storage.Backup.IncrementalBackupFileIntervalMin">
            <summary>
            Identifies how often will be created new file for backup (Minimum 5 minutes).
            Default value is one day
            </summary>
        </member>
        <member name="P:DBreeze.Storage.Backup.BackupFolderName">
            <summary>
            Folder where backup files will be created
            </summary>
        </member>
        <member name="M:DBreeze.Storage.Backup.BackupFileNamesParser.ParseFilename(System.String)">
            <summary>
            Helper for table file names transitions for backup
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.Backup.BackupFileNamesParser.ParseFilenameBack(System.UInt64)">
            <summary>
            
            </summary>
            <param name="filenumber"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.Backup.WriteBackupElement(System.UInt64,System.Byte,System.Int64,System.Byte[])">
            <summary>
            Represents incremental backup of protocol 1
            </summary>
            <param name="fileNumber"></param>
            <param name="type">0 - table file, 1 - rollback file, 2 - rollbackhelper, 3 - recreate table file, 5 - removing complete table </param>
            <param name="pos"></param>
            <param name="data"></param>
        </member>
        <member name="T:DBreeze.Storage.BackupRestorer">
            <summary>
            Access to Database restoration from incremental backups.
            </summary>
        </member>
        <member name="T:DBreeze.Storage.BackupRestorer.BackupRestorationProcess">
            <summary>
            Object characterizes the backup restoration process
            </summary>
        </member>
        <member name="P:DBreeze.Storage.BackupRestorer.BackupRestorationProcess.ReadinessInProcent">
            <summary>
            How many procesnt of restoration is done
            </summary>
        </member>
        <member name="P:DBreeze.Storage.BackupRestorer.BackupRestorationProcess.Finished">
            <summary>
            true when restore is completed
            </summary>
        </member>
        <member name="E:DBreeze.Storage.BackupRestorer.OnRestore">
            <summary>
            Subscribe on it to receive notification about restore process
            </summary>
        </member>
        <member name="P:DBreeze.Storage.BackupRestorer.DataBaseFolder">
            <summary>
            Place where resides or should reside database
            </summary>
        </member>
        <member name="P:DBreeze.Storage.BackupRestorer.BackupFolder">
            <summary>
            Place where reside incremnetal dbreeze backup files
            </summary>
        </member>
        <member name="F:DBreeze.Storage.BackupRestorer.ds">
            <summary>
            Holder of filenames and file handlers
            </summary>
        </member>
        <member name="M:DBreeze.Storage.BackupRestorer.StartRestoration">
            <summary>
            Starts backup restore routine
            </summary>
        </member>
        <member name="T:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander">
            <summary>
            NSR works via this interface
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.OpenRemoteTable(System.String)">
            <summary>
            Opens remote file (data, rollback and rollback helper), if it doesn't exists, then creates it.
            In background returns current rollback, rollback helper, data file length and RemoteTableId.
            All other operations are done using remote table id
            </summary>
            <param name="fileName"></param>        
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.CloseRemoteTable">
            <summary>
            Closes remote table (data, rollback and rollback helper)
            </summary>        
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.DeleteRemoteTable">
            <summary>
            Deletes remote table (data, rollback and rollback helper).
            </summary>
            <param name="fileName"></param>        
        </member>
        <member name="P:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.DataFileLength">
            <summary>
            Operations like OpenRemoteFile, Read etc always return back the length of data and rollback file, which must be set to this variable by interface implementer
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.DataFilePosition">
            <summary>
            Sets up data file position for reading or writing
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.RollbackFilePosition">
            <summary>
            Sets up rollback file position for reading or writing
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.RollbackHelperFilePosition">
            <summary>
            Sets up rollback file position for reading or writing
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.DataFileWrite(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Writes to remote data file, return sets DataFileLength
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.RollbackFileWrite(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Writes to remote rollback file, return sets RollbackFileLength
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.RollbackHelperFileWrite(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Writes to remote rollback file, return sets RollbackHelperFileLength
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.DataFileRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            DataFileRead
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.RollbackFileRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            RollbackFileRead
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.RollbackHelperFileRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            RollbackHelperFileRead
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.RollbackFileRecreate">
            <summary>
            RollbackFileRecreate
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.DataFileFlush">
            <summary>
            DataFileFlush
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.IRemoteInstanceCommander.RollbackFileFlush">
            <summary>
            RollbackFileFlush
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.OpenRemoteTable(System.String)">
            <summary>
            Always first command, which send table name and receives back RemoteTableId
            Opens remote table (data, rollback and rollback helper files), if it doesn't exists, then creates it.
            All other operations are based on this RemoteTableId.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.CloseRemoteTable">
            <summary>
            CloseRemoteTable, returns nothing
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DeleteRemoteTable">
            <summary>
            DeleteRemoteTable
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DataFileWrite(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Writes to remote data file, return sets DataFileLength
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="withFlush"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileWrite(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Writes to remote rollback file, return sets RollbackFileLength
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="withFlush"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackHelperFileWrite(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Writes to remote rollback helper file, return sets RollbackFileHelperLength
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="withFlush"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DataFileRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads Datafile
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            RollbackFileRead
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackHelperFileRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            RollbackHelperFileRead
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DataFileFlush">
            <summary>
            Data file Flush
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileFlush">
            <summary>
            Rollback file flush
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileRecreate">
            <summary>
            RollbackFileRecreate
            </summary>
        </member>
        <member name="T:DBreeze.Storage.RemoteInstance.RemoteTable">
            <summary>
            Represents one table, is managed by RemoteTablesHandler, server data, rollback and rollback helper files.
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.#ctor(System.String,System.UInt64)">
            <summary>
            
            </summary>
            <param name="_fileName"></param>
            <param name="tableId"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.OpenRemoteTable">
            <summary>
            OpenRemoteTable
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.CloseRemoteTable">
            <summary>
            CloseRemoteTable
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.DeleteRemoteTable">
            <summary>
            DeleteRemoteTable
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.DataFileWrite(System.Int64,System.Boolean,System.Byte[])">
            <summary>
            DataFileWrite
            </summary>
            <param name="position"></param>
            <param name="withFlush"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackFileWrite(System.Int64,System.Boolean,System.Byte[])">
            <summary>
            RollbackFileWrite
            </summary>
            <param name="position"></param>
            <param name="withFlush"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackHelperFileWrite(System.Int64,System.Boolean,System.Byte[])">
            <summary>
            RollbackFileWrite
            </summary>
            <param name="position"></param>
            <param name="withFlush"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.DataFileRead(System.Int64,System.Int32)">
            <summary>
            DataFileRead
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackFileRead(System.Int64,System.Int32)">
            <summary>
            RollbackFileRead
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackHelperFileRead(System.Int64,System.Int32)">
            <summary>
            RollbackHelperFileRead
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.DataFileFlush">
            <summary>
            DataFileFlush
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackFileFlush">
            <summary>
            RollbackFileFlush
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackFileRecreate">
            <summary>
            RollbackFileRecreate
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Storage.RemoteInstance.RemoteTablesHandler">
            <summary>
            ServerSide. Servs one local database.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RemoteInstance.RemoteTablesHandler._tIds">
            <summary>
            fileName to id binding
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTablesHandler.#ctor(System.String)">
            <summary>
            RemoteTablesHandler
            </summary>
            <param name="databasePreFolderPath"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTablesHandler.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTablesHandler.ParseProtocol(System.Byte[])">
            <summary>
            ParseProtocol
            </summary>
            <param name="protocol"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Storage.FSR">
            <summary>
            DBreeze random and sequential disk IO buffers implementation.
            Specially designed for DBreeze specific storage format.
            Not for common usage.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR.IsOperable">
            <summary>
            Indicates subsystem vitality
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR._randBuf">
            <summary>
            Random buffer
            </summary>
        </member>
        <member name="T:DBreeze.Storage.FSR.r">
            <summary>
            Record in rollback is characterized with 
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.r.o">
            <summary>
            offset in rollback file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.r.l">
            <summary>
            Length in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR._rollbackCache">
            <summary>
            Rollback cache
            Key is offset in data file, value is corresponding offset and length in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR.maxRandomBufferSize">
            <summary>
            Random buffer maximal size before flush
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR.MaxRollbackFileSize">
            <summary>
            Rollback file re-creation after initialization
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR.eofData">
            <summary>
            Pointer to the end of file, before current commit
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR._storageFixTime">
            <summary>
            DateTime when file was initialized. Is remembered by LTrieRow, based on this file.
            If file is change after RestoreTableFromTheOtherTable or RecreateFiles,
            LTrieRow will have different version and will return exception.
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.Length">
            <summary>
            Physical length of the storage file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.StorageFixTime">
            <summary>
            Returns time of file initiation, ead remarks on 
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.TrieSettings">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.DbreezeConfiguration">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.Table_FileName">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.RestoreInitRollback">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.ParseRollBackFile(System.Byte[])">
            <summary>
            
            </summary>
            <param name="rbd"></param>
        </member>
        <member name="M:DBreeze.Storage.FSR.RestoreTableFromTheOtherTable(System.String)">
            <summary>
            
            </summary>
            <param name="newTableFullPath"></param>
        </member>
        <member name="M:DBreeze.Storage.FSR.RecreateFiles">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.FlushSequentialBuffer">
            <summary>
            Must be called from lock_fs
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_WriteToTheEnd(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_WriteByOffset(System.Byte[],System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_WriteByOffset(System.Int64,System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.FSR.FlushRandomBuffer">
            <summary>
            Is called only from lock_fs and must be finished by calling NET_Flush
            </summary>     
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_Read(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_Read(System.Boolean,System.Int64,System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.FSR.Commit">
            <summary>
            Cleans all buffers and flushes data to the disk
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR.TransactionalCommitIsStarted">
            <summary>
            Transactional Commit is started
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.TransactionalCommit">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.TransactionalCommitIsFinished">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.TransactionalRollback">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.Rollback">
            <summary>
            Standard and transactional rollback
            </summary>
        </member>
        <member name="T:DBreeze.Storage.IStorage">
            <summary>
            Storage interface
            </summary>
        </member>
        <member name="M:DBreeze.Storage.IStorage.Table_Read(System.Boolean,System.Int64,System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache">true=reading threads, false = writing threads</param>
            <param name="offset"></param>
            <param name="quantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.IStorage.Table_Read(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache">true=reading threads, false = writing threads</param>
            <param name="offset"></param>
            <param name="quantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.IStorage.RestoreTableFromTheOtherTable(System.String)">
            <summary>
            
            </summary>
            <param name="newTableFullPath"></param>
        </member>
        <member name="P:DBreeze.Storage.IStorage.StorageFixTime">
            <summary>
            UTC DateTime when table was initialized
            </summary>
        </member>
        <member name="P:DBreeze.Storage.IStorage.Length">
            <summary>
            Length of the Storage
            </summary>
        </member>
        <member name="T:DBreeze.Storage.MemoryStorage">
            <summary>
            Memory storage
            </summary>
        </member>
        <member name="T:DBreeze.Storage.MemoryStorage.eMemoryExpandStartegy">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.#ctor(System.Int32,System.Int32,DBreeze.Storage.MemoryStorage.eMemoryExpandStartegy)">
            <summary>
            
            </summary>
            <param name="initialCapacity">Initial Memory Capacity in bytes</param>
            <param name="increaseOnBytes">Rules is strategy is FIXED_LENGTH_INCREASE, quantity of bytes to increse memory</param>
            <param name="strategy">Memory expand strategy</param>
        </member>
        <member name="P:DBreeze.Storage.MemoryStorage.RawBuffer">
            <summary>
            Gives an ability to access field itself. Must use external logical lock.
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Clear(System.Boolean)">
            <summary>
            Sets EOF pointer to 0.
            <para>USE withInternalArrayResize by necessity. If it's true then array will be re-initialized to initial capacity</para>
            <para>this also will call GC and the whole process will take some time.</para>
            <para>If false, only pointer EOF will be set to 0, capacity of the array will not be changed - very fast</para>
            </summary>
            <param name="withInternalArrayResize"></param>
        </member>
        <member name="P:DBreeze.Storage.MemoryStorage.EOF">
            <summary>
            End of file
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.GetFullData">
            <summary>
            Can return null
            </summary>
            <returns></returns>
        </member>
        <member name="P:DBreeze.Storage.MemoryStorage.MemorySize">
            <summary>
            Total reserved field length. EOF shows the end of useful information.
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Read(System.Int32,System.Int32)">
            <summary>
            If length = 0 returns new byte[0]
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write(System.Byte[]@,System.Int32)">
            <summary>
            Must be called from lock
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write_ToTheEnd(System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write_ToTheEnd(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write_ByOffset(System.Int32,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write_ByOffset(System.Int32,System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Writes_ByOffsets(System.Collections.Generic.Dictionary{System.Int64,System.Byte[]})">
            <summary>
            
            </summary>
            <param name="datas"></param>
        </member>
        <member name="T:DBreeze.Storage.MSR">
            <summary>
            DBreeze random and sequential disk IO buffers implementation.
            Specially designed for DBreeze specific storage format.
            Not for common usage.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR.IsOperable">
            <summary>
            Indicates subsystem vitality
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR._randBuf">
            <summary>
            Random buffer
            </summary>
        </member>
        <member name="T:DBreeze.Storage.MSR.r">
            <summary>
            Record in rollback is characterized with 
            </summary>
        </member>
        <member name="P:DBreeze.Storage.MSR.r.o">
            <summary>
            offset in rollback file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.MSR.r.l">
            <summary>
            Length in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR._rollbackCache">
            <summary>
            Rollback cache
            Key is offset in data file, value is corresponding offset and length in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR.maxRandomBufferSize">
            <summary>
            Random buffer maximal size before flush
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR.MaxRollbackFileSize">
            <summary>
            Rollback file re-creation after initialization
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR.eofData">
            <summary>
            Pointer to the end of file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR._storageFixTime">
            <summary>
            DateTime when file was initialized. Is remembered by LTrieRow, based on this file.
            If file is change after RestoreTableFromTheOtherTable or RecreateFiles,
            LTrieRow will have different version and will return exception.
            </summary>
        </member>
        <member name="P:DBreeze.Storage.MSR.Length">
            <summary>
            Physical length of the storage file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.MSR.StorageFixTime">
            <summary>
            Returns time of file initiation, ead remarks on 
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.RecreateFiles">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_WriteToTheEnd(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_WriteByOffset(System.Byte[],System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_WriteByOffset(System.Int64,System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.MSR.FlushRandomBuffer">
            <summary>
            Is called only from lock_fs and must be finished by calling NET_Flush
            </summary>
            <param name="commit"></param>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_Read(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache">if actual overwritten data must be used</param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_Read(System.Boolean,System.Int64,System.Int32)">
            <summary>
            
            </summary>
            <param name="readActual">if actual overwritten data must be used</param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MSR.Commit">
            <summary>
            Cleans all buffers and flushes data to the disk
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR.TransactionalCommitIsStarted">
            <summary>
            Transactional Commit is started
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.TransactionalCommit">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.TransactionalCommitIsFinished">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.TransactionalRollback">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.Rollback">
            <summary>
            Standard and transactional rollback
            </summary>
        </member>
        <member name="T:DBreeze.Storage.RISR">
            <summary>
            DBreeze Remote Instance SR implementation
            Specially designed for DBreeze specific storage format.
            Not for common usage.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR.IsOperable">
            <summary>
            Indicates subsystem vitality
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR._randBuf">
            <summary>
            Random buffer
            </summary>
        </member>
        <member name="T:DBreeze.Storage.RISR.r">
            <summary>
            Record in rollback is characterized with 
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.r.o">
            <summary>
            offset in rollback file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.r.l">
            <summary>
            Length in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR._rollbackCache">
            <summary>
            Rollback cache
            Key is offset in data file, value is corresponding offset and length in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR.maxRandomBufferSize">
            <summary>
            Random buffer maximal size before flush
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR.MaxRollbackFileSize">
            <summary>
            Rollback file re-creation after initialization
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR.eofData">
            <summary>
            Pointer to the end of file, before current commit
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR._storageFixTime">
            <summary>
            DateTime when file was initialized. Is remembered by LTrieRow, based on this file.
            If file is change after RestoreTableFromTheOtherTable or RecreateFiles,
            LTrieRow will have different version and will return exception.
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.Length">
            <summary>
            Physical length of the storage file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.StorageFixTime">
            <summary>
            Returns time of file initiation, ead remarks on 
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.TrieSettings">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.DbreezeConfiguration">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.Table_FileName">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.RestoreInitRollback">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.ParseRollBackFile(System.Byte[])">
            <summary>
            
            </summary>
            <param name="rbd"></param>
        </member>
        <member name="M:DBreeze.Storage.RISR.RestoreTableFromTheOtherTable(System.String)">
            <summary>
            
            </summary>
            <param name="newTableFullPath"></param>
        </member>
        <member name="M:DBreeze.Storage.RISR.RecreateFiles">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.FlushSequentialBuffer">
            <summary>
            Must be called from lock_fs
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_WriteToTheEnd(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_WriteByOffset(System.Byte[],System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_WriteByOffset(System.Int64,System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.RISR.FlushRandomBuffer">
            <summary>
            Is called only from lock_fs and must be finished by calling NET_Flush
            </summary>     
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_Read(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_Read(System.Boolean,System.Int64,System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RISR.Commit">
            <summary>
            Cleans all buffers and flushes data to the disk
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR.TransactionalCommitIsStarted">
            <summary>
            Transactional Commit is started
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.TransactionalCommit">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.TransactionalCommitIsFinished">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.TransactionalRollback">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.Rollback">
            <summary>
            Standard and transactional rollback
            </summary>
        </member>
        <member name="T:DBreeze.Storage.StorageLayer">
            <summary>
            Storage layer
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.POINTER_LENGTH">
            <summary>
            User parameter for the table.
            <para>Quantity of bytes which represent pointer inside of raw file (5 bytes = 1 Terrabyte, so the trie with 5 bytes pointer len can't be longer then 1 terrabyte).</para>
            <para>If you plan to have your table more then 1TB, set this value to bigger value, before table creation</para>
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.ROOT_SIZE">
            <summary>
            For internal needs
            Quantity of bytes which reside ROOT_NODE
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.ROOT_START">
            <summary>
            For internal needs.
            Offset where root should reside in the file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.InternalTable">
            <summary>
            If table is for internal purposes (like Scheme or Transaction Journal)
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.AlternativeTableStorageFolder">
            <summary>
            Next 3 concern alternative table storage pathes.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.ITransactable.ITRCommitFinished">
            <summary>
            Is called by Transaction Journal, to make root available for all and delete rollback file
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.ITransactable.TransactionIsFinished(System.Int32)">
            <summary>
            Transaction Coordinator notifies table that transaction is finished
            and table can clear ModificationThreadId and run RollBackProcedure (if transaction was finised without Commit)
            </summary>
            <param name="transactionThreadId"></param>
        </member>
        <member name="M:DBreeze.Transactions.ITransactable.ModificationThreadId(System.Int32)">
            <summary>
            TransactionsCoordinator via this function will explain to the table that transactionThreadId thread will make modificatons.
            later when calling fetch functions, table will be able to return different RootNodes depending upon the thread
            </summary>
            <param name="transactionThreadId"></param>
        </member>
        <member name="F:DBreeze.Transactions.TransactionsJournal.MaxlengthOfTransactionFile">
            <summary>
            We try to clear tranasction file, when its length is more then 10MB and if it's possible
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionsJournal._transactionsTables">
            <summary>
            Key: transaction number, counting up from the engine start
            Value: Dictionary containing as a Key usertableName, as value link to the table
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsJournal.AddTableForTransaction(System.UInt64,DBreeze.Transactions.ITransactable)">
            <summary>
            Every table inside of the transaction before calling Transaction Commit, goes to this in-memory dictionary
            </summary>
            <param name="tranNumber"></param>
            <param name="table"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsJournal.RemoveTransactionFromDictionary(System.UInt64)">
            <summary>
            Used in case of failed transaction of multiple tables, to clean in-memory dictionary
            </summary>
            <param name="tranNumber"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsJournal.GetTransactionNumber">
            <summary>
            Returns new transaction number
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Transactions.TransactionUnit">
            <summary>
            This object includes class Transaction (visible for the user) and holds internally technical transaction information.
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._transaction">
            <summary>
            Represents object which will be used by user, there we have all query methods, depending upon query we now if the table has to be locked or not.
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.TransactionsCoordinator">
            <summary>
            Easy access to transactin coordinator for the Transaction which is visible for the user
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.Transaction">
            <summary>
            Transaction visible for the user
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.TransactionThreadId">
            <summary>
            
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._sync_transactionWriteTables">
            <summary>
            Lock for all tables definitions inside current transaction
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._transactionWriteTables">
            <summary>
            It holds all tables marked for possible mutations
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._transactionWriteTablesAwaitingReservation">
            <summary>
            List of tables which are waiting for reservation for writing, we need it to predict deadlock situations.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.AddTransactionWriteTablesAwaitingReservation(System.Collections.Generic.List{System.String})">
            <summary>
            Used by TransactionCoordinator.RegisterWriteTablesForTransaction
            </summary>
            <param name="tablesNames"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.AddTransactionWriteTable(System.String,DBreeze.Transactions.ITransactable)">
            <summary>
            Adds a table which will take place in transaction operations.
            Reserved has value null, Real (which are acquired by Transaction for Write) has ITransactable filled.
            ITransactable = null, gives to differ from toched and reserved.
            </summary>
            <param name="tableName"></param>
            <param name="table">if null - will be added to Reservation table</param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.GetTransactionWriteTables">
            <summary>
            Doesn't need pattern check
            Returns all tables which took place in write operation for the current transaction
            Without reserved as Text tables only which have real ITransactable inside
            </summary>
            <returns></returns>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.TransactionWriteTablesCount">
            <summary>
            returns count of reserved tables, used by transaction just to find out if reservation (or first table modification) was done or not.
            reservation can be done only once.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.If_TableIsReservedForWrite(System.String)">
            <summary>
            Used inside of Transaction, we can choose fot READ or READ_SYNCHRO for READ FUNCs
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.GetTransactionWriteTablesNames">
            <summary>
            Returns only table names for reservation
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.Commit">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.RollBack">
            <summary>
            
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionsCoordinator._transactions">
            <summary>
            Dictionary of all active transactions. Key is ManagedThreadId
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionsCoordinator.GetSchema">
            <summary>
            Fast access to the Schema object.
            Used by Transaction class
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTransaction(System.Int32,DBreeze.eTransactionTablesLockTypes,System.String[])">
            <summary>
            
            </summary>
            <param name="transactionType">0 = standard transaction, 1 - locked transaction</param>
            <param name="lockType"></param>
            <param name="tables"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTransactionUnit(System.Int32)">
            <summary>
            
            </summary>
            <param name="transactionThreadId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.UnregisterTransaction(System.Int32)">
            <summary>
            
            </summary>
            <param name="transactionThreadId"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.UnregisterAllTransactions">
            <summary>
            Is called by the engine on Dispose.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.RegisterWriteTablesForTransaction(System.Int32,System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            Access synchronizer.
            All calls of the WRITE LOCATOR come over this function.
            </summary>
            <param name="transactionThreadId"></param>
            <param name="tablesNames"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTable_WRITE(System.String,System.Int32)">
            <summary>
            Can return NULL (if DbIsNotOperatable)
            </summary>
            <param name="tableName"></param>
            <param name="transactionThreadId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTable_READ(System.String,System.Int32,System.Boolean)">
            <summary>
            Can return NULL if table doesn't exist
            Can return NULL (if DbIsNotOperatable)
            
            Differs from GetTable_Write:
            1. table is not registered for Write;
            2. Table is not created, if doesn't exist.
            </summary>
            <param name="tableName"></param>
            <param name="transactionThreadId"></param>
            <param name="ignoreThreadIdCheck"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.StopEngine">
            <summary>
            Normal Engine Stop, usually in case of Main Thread or DLL disposing
            </summary>
        </member>
        <member name="T:DBreeze.Transactions.RandomKeySorter">
            <summary>
            Speeding up, space economy. Represents a mechanism helping to store entites into the memory, before insert or remove.
            When AutomaticFlushLimitQuantityPerTable per table (default 10000) is exceed or 
            within Commit command, all entites will be flushed (first removed then inserted) on the disk 
            sorted by key ascending
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.RandomKeySorter.AutomaticFlushLimitQuantityPerTable">
            <summary>
            <para>NOT USED ANYMORE</para>
            Value indicating when content should be cleared. Default is 1000000 (inserts and removes)
            <para>Getting rid of Automatic flush, that makes inefficient TryGetValueByKey after flushing (will need always to check HD if not found in sorter)</para> 
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.RandomKeySorter.TablesWithOverwriteIsNotAllowed(System.String)">
            <summary>
            Internal regulator telling, that specified tables should work via fast update
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.RandomKeySorter.TryGetValueByKey(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.RandomKeySorter.Insert``2(System.String,``0,``1)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>        
        </member>
        <member name="M:DBreeze.Transactions.RandomKeySorter.Remove``1(System.String,``0)">
            <summary>
            Removes from the table key
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
        </member>
        <member name="F:DBreeze.Transactions.RandomKeySorter.tbls">
            <summary>
            Contains writing LTrie tables
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.RandomKeySorter.Flush">
            <summary>
            Flushing all 
            </summary>
        </member>
        <member name="T:DBreeze.Transactions.Transaction">
            <summary>
            Transaction
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.ManagedThreadId">
            <summary>
            Managed threadId of the transaction
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.CreatedUdt">
            <summary>
            DateTime.UtcNow.Ticks - time of transaction creation
            Combination of ManagedThreadId and CreatedUdt, gives us unique transaction identifier
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction._transactionType">
            <summary>
            0 - standard transaction, 1 - locked transaction (Shared Exclusive)
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.tsh">
            <summary>
            TextSearchHandler instance
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.RandomKeySorter">
            <summary>
            Speeding up, space economy. Represents a mechanism helping to store entites into the memory, before insert or remove.
            When AutomaticFlushLimitQuantityPerTable per table (default 10000) is exceed or 
            within Commit command, all entites will be flushed (first removed then inserted) on the disk 
            sorted by key ascending
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.#ctor(System.Int32,DBreeze.Transactions.TransactionUnit,DBreeze.eTransactionTablesLockTypes,System.String[])">
            <summary>
            Transaction
            </summary>
            <param name="transactionType"></param>
            <param name="transactionUnit"></param>
            <param name="lockType"></param>
            <param name="tables"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.Transaction.ValuesLazyLoadingIsOn">
            <summary>
            When it's on iterators return Row with the key and a pointer to the value.
            <para>Value will be read out when we call it Row.Value.</para>
            <para>When it's off we read value together with the key in one round</para>
            <para>Default is true</para>
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SynchronizeTables(System.Collections.Generic.IList{System.String})">
            <summary>
            Use before any table modification command inside of the transaction.
            <para>In case if transaction is going to modify only 1 table, reservation is not necessary, there is no danger of the deadlock.</para>
            <para></para>
            <para>Table Names available patterns:</para>
            <para>$ * #</para>
            <para>* - 1 or more of any symbol kind (every symbol after * will be cutted): Items* U Items123/Pictures</para>
            <para># - symbols (except slash) followed by slash and minimum another symbol: Items#/Picture U Items123/Picture</para>
            <para>$ - 1 or more symbols except slash (every symbol after $ will be cutted): Items$ U Items123;  Items$ !U Items123/Pictures </para>
            </summary>
            <param name="tablesNamesPatterns">can be either tableName or pattern like Articles#/Items*</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SynchronizeTables(System.String[])">
            <summary>
             Use before any table modification command inside of transaction
            <para>In case if transaction is going to modify only 1 table, reservation is not necessary, there is no danger of the deadlock.</para>
            <para></para>
            <para>Table Names available patterns:</para>
            <para>$ * #</para>
            <para>* - 1 or more of any symbol kind (every symbol after * will be cutted): Items* U Items123/Pictures</para>
            <para># - symbols (except slash) followed by slash and minimum another symbol: Items#/Picture U Items123/Picture</para>
            <para>$ - 1 or more symbols except slash (every symbol after $ will be cutted): Items$ U Items123;  Items$ !U Items123/Pictures </para>
            </summary>
            <param name="tablesNamesPatterns"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.AddOpenTable(System.String)">
            <summary>
            This must be called only if we use not cached opening
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.transactionWriteTables">
            <summary>
            Small buffer for the tables where we are going to write in.
            It will boost performance in case of Bulk inserts or updates
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.GetWriteTableFromBuffer(System.String)">
            <summary>
            Automatically tries to take Write Table from buffer or from system, throws exception if smth. happens
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.transactionReadTables">
            <summary>
            Small buffer for the tables, we are going to read from.
            </summary>
        </member>
        <member name="T:DBreeze.Transactions.Transaction.Rtbe">
            <summary>
            Technical class, who holds reference to the table and its last modification dts
            ReadTableElement
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.GetReadTableFromBuffer(System.String,DBreeze.Tries.ITrieRootNode@)">
            <summary>
            IS USED BY NON-RANGE SELECTS OPERATORS
            Retuns LTrie (or later by necessity ITrie) and as out variable ReadRootNode which must be used for READ FUNC data acquiring.
            READ FUNCs calling this proc will receive table and as out var. root, this root will be supplied to the trie.
            If root is null, then write root will be used.
            If table is null - table doesn't exist.
            </summary>
            <param name="tableName"></param>
            <param name="root"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.ReadVisibilityScopeModifier_GenerateNewTableForRead">
            <summary>
            <para>Will be used when getting new table for ReadVisibilityScope=true in this transaction.</para>
            If true, will create new read-table, if false, will try to reuse cached (once created) existing read-table (or create new cached READ-TABLE).
            <para>Switch ReadVisibilityScopeModifier_GenerateNewTableForRead can be changed many times during transaction.</para>
            May be switched to true, before call Select...,AsReadVisibilityScope = true, then can be switched back.
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.ReadVisibilityScopeModifier_DirtyRead">
            <summary>
            <para>Works in case if ReadVisibilityScopeModifier_GenerateNewTableForRead = true.</para>
            <para>When true, will show also updated, but not committed changes, to the moment of request.</para>
            <para>Default is false</para>
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.GetReadTableFromBuffer(System.String,DBreeze.Tries.ITrieRootNode@,System.Boolean)">
            <summary>
            Retuns LTrie (or later by necessity ITrie) and as out variable ReadRootNode which must be used for READ FUNC data acquiring.
            READ FUNCs calling this proc will receive table and as out var. root, this root will be supplied to the trie.
            If root is null, then write root will be used.
            If table is null - table doesn't exist.
            </summary>
            <param name="tableName"></param>
            <param name="root"></param>
            <param name="AsForRead"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Commit">
            <summary>
            Commits all changes made inside of the current transaction.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Rollback">
            <summary>
            Rollsback all changes made by current transaction before last Commit.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveRandomKeySorter``1(System.String,``0)">
            <summary>
            Syntax-sugar for  this.RandomKeySorter.Remove(tableName, key, value);
            
            Speeding up, space economy. Represents a mechanism helping to store entites into the memory, before insert or remove.
            When AutomaticFlushLimitQuantityPerTable per table (default 10000) is exceed or 
            within Commit command, all entites will be flushed (first removed then inserted) on the disk 
            sorted by key ascending
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveKey``1(System.String,``0)">
            <summary>
            Removes specified key, if it existed
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveKey``1(System.String,``0,System.Boolean@)">
            <summary>
            Removes specified key, if it exists.
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system, before removing</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveKey``1(System.String,``0,System.Boolean@,System.Byte[]@)">
            <summary>
            Removes specified key, if it exists. Return value which was deleted if WasRemoved is true.
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system, before removing</param>
            <param name="deletedValue">Will hold deleted value if WasRemoved is true</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveKey``1(System.String,``0,System.Boolean@,System.Boolean,System.Byte[]@)">
            <summary>
            Internal function.
            Removes specified key, if it exists. Can return value which was deleted if WasRemoved is true
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system, before removing</param>
            <param name="retrieveDeletedValue">indicates if system should retrieve deleted value</param>
            <param name="deletedValue"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveAllKeys(System.String,System.Boolean)">
            <summary>
            Removes all records in the table
            </summary>
            <param name="tableName"></param>
            <param name="withFileRecreation">also recreates table file, if true</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ChangeKey``1(System.String,``0,``0)">
            <summary>
            Renames key old its value on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="oldKey"></param>
            <param name="newKey"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ChangeKey``1(System.String,``0,``0,System.Byte[]@)">
            <summary>
            Renames key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ChangeKey``1(System.String,``0,``0,System.Byte[]@,System.Boolean@)">
            <summary>
            Renames key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
            <param name="WasChanged">indicates that oldKey existed and was succesfully changed</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertDataBlock(System.String,System.Byte[],System.Byte[])">
            <summary>
            Insert a dynamic size data block in the table storage, returns 16 bytes length identifier
            <para></para>
            which can be stored in a table value from specified index.
            <para></para>
            Retrieve such DataBlock we can using Row.GetDataBlock.
            <para>The same statement is used to update datablock, received value must update row value who holds reference to it.</para>
            <para>Must be used as row column with dynamic length</para>
            </summary>
            <param name="tableName"></param>
            <param name="initialPointer">if null creates new data block, if not null tries to overwrite existing data block</param>
            <param name="data"></param>
            <returns>returns created data block parameters of fixed 16 bytes length, which can be stored in the row value
            <para>and later reused for getting data block back</para>
            </returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertDataBlockWithFixedAddress``1(System.String,System.Byte[],``0)">
            <summary>
            Modification of InsertDataBlock.
            Insert a dynamic size data block in the table storage, returns a fixed 16 bytes length identifier -
            it never changes even the value is updated.
            </summary>
            <param name="tableName"></param>
            <param name="initialPointer">if null creates new data block, if not null tries to overwrite existing data block</param>
            <param name="data"></param>        
            <returns></returns>        
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDataBlock(System.String,System.Byte[])">
            <summary>
            Another way (second is via row by index where pointer is stored) to get stored data block
            </summary>
            <param name="tableName"></param>
            <param name="ptrToDataBlock">16 byte pointer identifier, received after insertDataBlock</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDataBlockWithFixedAddress``1(System.String,System.Byte[])">
            <summary>
            Gets data block with fixed identifier saved via InsertDataBlockWithFixedAddress
            </summary>
            <param name="tableName"></param>
            <param name="ptrToDataBlock"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertRandomKeySorter``2(System.String,``0,``1)">
            <summary>
            Syntax-sugar for  this.RandomKeySorter.Insert(tableName, key, value);
            
            Speeding up, space economy. Represents a mechanism helping to store entites into the memory, before insert or remove.
            When AutomaticFlushLimitQuantityPerTable per table (default 10000) is exceed or 
            within Commit command, all entites will be flushed (first removed then inserted) on the disk 
            sorted by key ascending
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ObjectGetNewIdentity``1(System.String,System.Byte[],System.UInt32)">
            <summary>
            Concept of the objects storage (read docu from 20170321)
            Automatically gets monotonically grown entity ID (automatically will be stored in table after commit).
            Table can contain and handle many monotonically grown identities, 
            but for that must be explicitely set addressOfIdentity
            </summary>
            <typeparam name="TIdentity">type of identity (long,ulong,int,uint,short,ushort)</typeparam>
            <param name="tableName">Table name</param>
            <param name="addressOfIdentity">by default is stored to th key address byte[]{0}</param>
            <param name="seed">Step of growth</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ObjectInsert``1(System.String,DBreeze.Objects.DBreezeObject{``0},System.Boolean)">
            <summary>
            Concept of the objects storage (read docu from 20170321)
            Insert/Updates entity and its secondary keys
            </summary>
            <typeparam name="TObject"></typeparam>
            <param name="tableName">Table name</param>
            <param name="toInsert">Configuration for the inserting object</param>
            <param name="speedUpdate">Set to true to increase update speed (table can consume more physical space)</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ObjectRemove(System.String,System.Byte[],System.Boolean)">
            <summary>
            Concept of the objects storage (read docu from 20170321)
            Removes entity and its keys
            </summary>
            <param name="tableName">Table name</param>
            <param name="index">Any of formed index to lookup the entity for deletion</param>
            <param name="speedUpdate">Aet to true to increase update speed (table can consume more physical space)</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ObjectGetByFixedAddress``1(System.String,System.Byte[])">
            <summary>
            Concept of the objects storage (read docu from 20170321).
            Gets object directly if available its fixed address in the file, can be useful for the indexes stored in different from the object table.
            Returns DBreezeObject, to get entity use property.Entity. If returns null, then such entity doesn't exist.
            </summary>
            <typeparam name="TVal"></typeparam>
            <param name="tableName">name of the table</param>
            <param name="address">fixed address in the file</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1,System.Byte[]@)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1,System.Byte[]@,System.Boolean@)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1,System.Byte[]@,System.Boolean@,System.Boolean)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <param name="dontUpdateIfExists">When true - if value exists, we dont update it. If WasUpdated = true then value exists, if false - we have inserted new one</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Technical_SetTable_OverwriteIsNotAllowed(System.String)">
            <summary>
            <para>After the end of transaction overwrite will be allowed again.</para>
            <para>Concerns overwriting of values, trie search nodes and dataBlocks.</para>
            <para>ref. documentation from [20130412]</para>
            </summary>
            <param name="tableName"></param>      
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertPart``2(System.String,``0,``1,System.UInt32)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertPart``2(System.String,``0,``1,System.UInt32,System.Byte[]@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param> 
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertPart``2(System.String,``0,``1,System.UInt32,System.Byte[]@,System.Boolean@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para>
            <para>Second generic parameter represents datatype of the inserting parameter in the middle of the value</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param> 
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param> 
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertTable``1(System.String,``0,System.UInt32)">
            <summary>
            Will create internal table if it doesn't exist and return it.
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectTable``1(System.String,``0,System.UInt32)">
            <summary>
            If internal table doesn't exist will not create it but must always return 
            NestedTable, which will be internally marked as absent. 
            In this case all Add/Remove operations will have to throw exception and
            Select operations will return their default values
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertDictionary``3(System.String,``0,System.Collections.Generic.Dictionary{``1,``2},System.UInt32,System.Boolean)">
            <summary>
            Inserts a dictionary into master-table row.
            <para></para>
            Actually creates a new table inside of master table row and handles it like table with TDictionaryKey key any TDictionaryValue value.
            <para></para>
            If new Dictionary is supplied then non-existing keys in supplied DB will be removed from db
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get dictionary use SelectDictionary</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertDictionary``2(System.String,System.Collections.Generic.Dictionary{``0,``1},System.Boolean)">
            <summary>
            Inserts a dictionary into master-table
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDictionary``3(System.String,``0,System.UInt32)">
            <summary>
            Selects complete table from master-table row nested table, by row nested-table index as Dictionary.
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDictionary``2(System.String)">
            <summary>
            Selects complete master-table as Dictionary
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertHashSet``2(System.String,``0,System.Collections.Generic.HashSet{``1},System.UInt32,System.Boolean)">
            <summary>
            Inserts a HashSet (unique list of Keys) into master-table row.
            <para></para>
            Actually creates a new table inside of master table row and handles it like table with THashSetKey key any byte[] == null value.
            <para></para>
            If new HashSet is supplied then non-existing keys in supplied DB will be removed from db (withValuesRemove=true)
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get HashSet use SelectHashSet</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertHashSet``1(System.String,System.Collections.Generic.HashSet{``0},System.Boolean)">
            <summary>
            Inserts a HashSet (unique list of Keys) into master-table itself
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectHashSet``2(System.String,``0,System.UInt32)">
            <summary>
            Selects complete table from master-table row nested table, by row nested-table index as HashSet (unique list of Keys).
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectHashSet``1(System.String)">
            <summary>
            Selects complete master-table as a HashSet into memory
            </summary>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Count(System.String)">
            <summary>
            Returns records quantity inside of the the table
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Max``2(System.String)">
            <summary>
            Returns row with the maximal key.
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Min``2(System.String)">
            <summary>
            Returns row with the minimal key.
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.TextInsert(System.String,System.Byte[],System.String,System.String,System.Boolean,System.Int32)">
            <summary>
            Inserts/Updates searchable words per external documentID. Automatically removes disappeared words and add new words - smart update of changed words)
            </summary>
            <param name="tableName">Real DBreeze table name, used to store text index for the group of documents. Must be added to tran.SynchronizeTables by programmer.</param>
            <param name="documentId">External document id, it will be returned after executing TextSearch.block.GetDocumentIDs</param>        
            <param name="containsWords">Space separated words, which will be stored using "contains" logic.</param>
            <param name="fullMatchWords">Space separated words, which will be stored using "full-match" logic (they can be also search via contains words by StartsWith logic)</param>
            <param name="deferredIndexing"> Means that document will be indexed in parallel thread and possibly search functionality for the document
            will be available a bit later after commit. 
            It's good for the fast Commits while inserting relatively large searchables-set .
            Default value is false, means that searchables will be indexed together with Commit and will be available at the same time.</param>
            <param name="containsMinimalLength"> Minimal lenght of the word to be searched using "contains" logic. Default is 3. </param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.TextAppend(System.String,System.Byte[],System.String,System.String,System.Boolean,System.Int32)">
            <summary>
            Appends words to the searchable set of the external documentID
            </summary>
            <param name="tableName">Real DBreeze table name, used to store text index for the group of documents. Must be added to tran.SynchronizeTables by programmer.</param>
            <param name="documentId">External document id, it will be returned after executing TextSearch.block.GetDocumentIDs</param>      
            <param name="containsWords">Space separated words, which will be stored using "contains" logic.</param>
            <param name="fullMatchWords">Space separated words, which will be stored using "full-match" logic</param>
            <param name="deferredIndexing"> Means that document will be indexed in parallel thread and possible search will be available a bit later after commit. 
            It's good for the fast Commits while inserting relatively large searchables-set .
            Default value is false, means that searchables will be indexed together with Commit and will be available at the same time.</param>
            <param name="containsMinimalLength"> Minimal lenght of the word to be searched using "contains" logic. Default is 3. </param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.TextRemove(System.String,System.Byte[],System.String,System.Boolean,System.Int32)">
            <summary>
            Removes FULL-MATCH words from the searchable set of the external documentID 
            </summary>
            <param name="tableName">Real DBreeze table name, used to store text index for the group of documents. Must be added to tran.SynchronizeTables by programmer.</param>
            <param name="documentId">External document id, it will be returned after executing TextSearch.block.GetDocumentIDs</param>        
            <param name="fullMatchWords">Space separated words, which will be stored using "full-match" logic</param>
            <param name="deferredIndexing"> Means that document will be indexed in parallel thread and possible search will be available a bit later after commit. 
            It's good for the fast Commits while inserting relatively large searchables-set .
            Default value is false, means that searchables will be indexed together with Commit and will be available at the same time.</param>
            <param name="containsMinimalLength"> Minimal lenght of the word to be searched using "contains" logic. Default is 3. </param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.TextRemoveAll(System.String,System.Byte[],System.Boolean)">
            <summary>
            Removes external documentID from the search index
            </summary>
            <param name="tableName">Real DBreeze table name, used to store text index for the group of documents. Must be added to tran.SynchronizeTables by programmer.</param>
            <param name="documentId">External document id, it will be returned after executing TextSearch.block.GetDocumentIDs</param>  
            <param name="deferredIndexing"> Means that document will be indexed in parallel thread and possible search will be available a bit later after commit. 
            It's good for the fast Commits while inserting relatively large searchables-set .
            Default value is false, means that searchables will be indexed together with Commit and will be available at the same time.</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.TextGetDocumentsSearchables(System.String,System.Collections.Generic.HashSet{System.Byte[]})">
            <summary>
            Returns existng searchables for the given documents external IDs
            </summary>
            <param name="tableName">Real DBreeze table name, used to store text index for the group of documents. Must be added to tran.SynchronizeTables by programmer.</param>
            <param name="documentIds"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.TextSearch(System.String)">
            <summary>
            Returns TextSearchTable (word aligned bitmap index manager for the search-index table). 
            Allows to make logical block based comparative operations.
            </summary>
            <param name="tableName">Real DBreeze table name, used to store text index for the group of documents. Must be added to tran.SynchronizeTables by programmer.</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.TextSearchHandlerCommit">
            <summary>
            Is called before COMMIT only
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.TextSearchHandlerAfterCommit">
            <summary>
            Is called after COMMIT
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Select``2(System.String,``0,System.Boolean)">
            <summary>
            Selects specified key from the table
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, select will return key/value,</para>
            <para>like it was before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDirect``2(System.String,System.Byte[])">
            <summary>
            Returns Row by supplying direct pointer to key/value in the file.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="refToInsertedValue"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForward``2(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackward``2(System.String,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartFrom``2(System.String,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="includeStartFromKey">if start key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartFrom``2(System.String,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="includeStartFromKey">if start key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified StartKey up to specified StopKey
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Multi_SelectForwardFromTo``2(System.Collections.Generic.HashSet{System.String},``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates multiple tables forward (ordered by key ascending). Starting from specified StartKey up to specified StopKey,
            returning minimal values from different tables first. If several tables contain the same values they will be supplied in 
            order of supplied table names. Keys in all tables must have the same structure and of course length, otherwise exception
            will be thrown
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tables"></param>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <param name="AsReadVisibilityScope"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified StartKey up to specified StopKey
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <param name="grabSomeLeadingRecords">helps to grab several leading records before statrKey</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified StartKey down to specified StopKey.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Multi_SelectBackwardFromTo``2(System.Collections.Generic.HashSet{System.String},``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates multiple tables backward (ordered by key descending). Starting from specified StartKey down to specified StopKey,
            returning maximal values from different tables first. If several tables contain the same values they will be supplied in 
            order of the supplied table names. Keys in all tables must have the same structure and, of course, length, otherwise exception
            will be thrown.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tables"></param>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <param name="AsReadVisibilityScope"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified StartKey down to specified StopKey.
            Contains grabSomeLeadingRecords, that helps to grab several leading records before statrKey
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <param name="grabSomeLeadingRecords">helps to grab several leading records before statrKey</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartsWith``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting and including specified key part (big-endian from byte[] point of view)</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartsWithClosestToPrefix``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartsWithClosestToPrefix``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartsWith``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting and including specified key part (big-endian from byte[] point of view)</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardSkip``2(System.String,System.UInt64,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending), skipping from the first key specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardSkip``2(System.String,System.UInt64,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending), skipping from the last key back specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardSkipFrom``2(System.String,``0,System.UInt64,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending), skipping from specified key specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardSkipFrom``2(System.String,``0,System.UInt64,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending), skipping from specified key back specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="skippingQuantity">if start key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RestoreTableFromTheOtherFile(System.String,System.String,System.Boolean)">
            <summary>
            <para>Experimenting. Replaces existing table with the other table, created out of this engine or from the table that belongs to the engine.</para>
            <para>Reading threads of tableName will wait till this operation occurs.</para>
            <para>Note that source table files will be deleted. </para>
            <para>Use when source table is a temporary table.</para>
            </summary>
            <param name="tableName"></param>
            <param name="newTableFullPath">Depends on thisEngineTable argument, if thisEngineTable == true then full path to the file is supplied, otherwise only source-tableName</param>
            <param name="thisEngineTable">default false, indicates that table belongs to the engine and all open file pointers on it will be closed, use with temporary tables.</param>
        </member>
        <member name="T:DBreeze.Transactions.Transaction.VectorTableParameters`1">
            <summary>
            Setup vector layer bound to a table
            </summary>
            <typeparam name="TVector">Can be float[] or double[], Please note that it is preferable to use float[] for a vector database - precision is acceptable.</typeparam>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.VectorTableParameters`1.GetItem">
            <summary>
            <para>Can be used when vectors self are already stored somewhere and this engine is used only for indexing.</para>
            <para>Otherwise vectors will also be stored in the table.</para>
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.VectorTableParameters`1.QuantityOfLogicalProcessorToCompute">
            <summary>
            <para>Default is 0 - will take about 70% of available CPU's to compute HNSW graph.</para>
            <para>Maximal can be used Environment.ProcessorCount</para>
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.VectorTableParameters`1.BucketSize">
            <summary>
            <para>Vectors connections are grouped into buckets. Each bucket can hold up to BucketSize quantity (can be increased after inserts).</para>
            <para>Buckets are created automatically.</para>
            <para>Default is 100000. With 10 buckets - 1MLN vectors.</para>
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.VectorTableParameters`1.NeighbourSelection">
            <summary>
            Default is NeighbourSelectSimple, part of HNSW algorithm (unsafe - can't be changed after the first isnert - take care)
            </summary>
        </member>
        <member name="T:DBreeze.Transactions.Transaction.VectorTableParameters`1.eNeighbourSelectionHeuristic">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InitVectorTranF``1(System.String,DBreeze.Transactions.Transaction.VectorTableParameters{System.Single[]})">
            <summary>
            
            </summary>
            <typeparam name="TVector"></typeparam>
            <param name="tableName"></param>
            <param name="vectorTableParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InitVectorTranD``1(System.String,DBreeze.Transactions.Transaction.VectorTableParameters{System.Double[]})">
            <summary>
            
            </summary>
            <typeparam name="TVector"></typeparam>
            <param name="tableName"></param>
            <param name="vectorTableParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.VectorsCount``1(System.String,DBreeze.Transactions.Transaction.VectorTableParameters{``0})">
            <summary>
            
            </summary>
            <typeparam name="TVector"></typeparam>
            <param name="tableName"></param>
            <param name="vectorTableParameters"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.VectorsGetByExternalId(System.String,System.Collections.Generic.List{System.Int64},DBreeze.Transactions.Transaction.VectorTableParameters{System.Single[]})">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="externalIds"></param>
            <param name="vectorTableParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.VectorsGetByExternalId(System.String,System.Collections.Generic.List{System.Int64},DBreeze.Transactions.Transaction.VectorTableParameters{System.Double[]})">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="externalIds"></param>
            <param name="vectorTableParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.VectorsInsert(System.String,System.Collections.Generic.IList{System.ValueTuple{System.Int64,System.Single[]}},DBreeze.Transactions.Transaction.VectorTableParameters{System.Single[]})">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="vectors">(long ExternalId of the Vector, float[] vector itself - will be auto normalized)</param>
            <param name="vectorTableParameters"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.VectorsInsert(System.String,System.Collections.Generic.IList{System.ValueTuple{System.Int64,System.Double[]}},DBreeze.Transactions.Transaction.VectorTableParameters{System.Double[]})">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="vectors">(long ExternalId of the Vector, double[] vector itself - will be auto normalized)</param>
            <param name="vectorTableParameters"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.VectorsSearchSimilar(System.String,System.Single[],System.Int32,DBreeze.Transactions.Transaction.VectorTableParameters{System.Single[]})">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="queryVector">find vectors in db closest to queryVector. queryVector will be auto-normalized</param>
            <param name="quantity">finds 'quantity' closest vectors</param>
            <param name="vectorTableParameters"></param>
            <returns>Returns ExternalIDs of closest vectors to the queryVector and distance between them sorted ascending</returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.VectorsSearchSimilar(System.String,System.Double[],System.Int32,DBreeze.Transactions.Transaction.VectorTableParameters{System.Double[]})">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="queryVector">find vectors in db closest to queryVector. queryVector will be auto-normalized</param>
            <param name="quantity">finds 'quantity' closest vectors</param>
            <param name="vectorTableParameters"></param>
            <returns>Returns ExternalIDs of closest vectors to the queryVector and distance between them sorted ascending</returns>        
        </member>
        <member name="M:DBreeze.Transactions.Transaction.VectorsDoIndexing(System.String,System.Collections.Generic.List{System.Int32})">
            <summary>
            CAP Possible future implementation, can be called from TextDeferredIndexer
            </summary>
            <param name="tableName"></param>
            <param name="internalIDs">must be already sorted ascending</param>
        </member>
        <member name="M:DBreeze.TransactionTablesLocker.AddSession(DBreeze.eTransactionTablesLockTypes,System.String[])">
            <summary>
            
            </summary>
            <param name="lockType"></param>
            <param name="tables"></param>
            <returns>false if thread grants access, false if thread is in a queue</returns>
        </member>
        <member name="M:DBreeze.TransactionTablesLocker.RemoveSession">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.TransactionTablesLocker.Dispose">
            <summary>
            MUST BE CALLED BY ENGINE DISPOSE (After all other DBreeze disposes)
            </summary>
        </member>
        <member name="T:DBreeze.Tries.ITrieRootNode">
            <summary>
            Identifies any type of RootNode in different tries
            </summary>
        </member>
        <member name="M:DBreeze.Utils.Async.AsyncOperations.DoAsync``1(System.Action{``0},``0,System.Action)">
            <summary>
            Executes async, then calls Callback function
            </summary>
            <typeparam name="TInput"></typeparam>
            <param name="f"></param>
            <param name="arg"></param>
            <param name="callback"></param>
        </member>
        <member name="T:DBreeze.Utils.BloomFilter.Filter`1.HashFunction">
            <summary>
            A function that can be used to hash input.
            </summary>
            <param name="input">The values to be hashed.</param>
            <returns>The resulting hash code.</returns>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32)">
            <summary>
            Creates a new Bloom filter, specifying an error rate of 1/capacity, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            A secondary hash function will be provided for you if your type T is either string or int. Otherwise an exception will be thrown. If you are not using these types please use the overload that supports custom hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Bloom filter, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            A secondary hash function will be provided for you if your type T is either string or int. Otherwise an exception will be thrown. If you are not using these types please use the overload that supports custom hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,DBreeze.Utils.BloomFilter.Filter{`0}.HashFunction)">
            <summary>
            Creates a new Bloom filter, specifying an error rate of 1/capacity, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, and T is string or int a hash function will be provided for you.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,System.Single,DBreeze.Utils.BloomFilter.Filter{`0}.HashFunction)">
            <summary>
            Creates a new Bloom filter, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, and T is string or int a hash function will be provided for you.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,System.Single,DBreeze.Utils.BloomFilter.Filter{`0}.HashFunction,System.Int32,System.Int32)">
            <summary>
            Creates a new Bloom filter.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, and T is string or int a hash function will be provided for you.</param>
            <param name="m">The number of elements in the BitArray.</param>
            <param name="k">The number of hash functions to use.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.Add(`0)">
            <summary>
            Adds a new item to the filter. It cannot be removed.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.Contains(`0)">
            <summary>
            Checks for the existance of the item in the filter for a given probability.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:DBreeze.Utils.BloomFilter.Filter`1.Truthiness">
            <summary>
            The ratio of false to true bits in the filter. E.g., 1 true bit in a 10 bit filter means a truthiness of 0.1.
            </summary>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.computeHash(System.Int32,System.Int32,System.Int32)">
            <summary>
            Performs Dillinger and Manolios double hashing. 
            </summary>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.hashInt32(`0)">
            <summary>
            Hashes a 32-bit signed int using Thomas Wang's method v3.1 (http://www.concentric.net/~Ttwang/tech/inthash.htm).
            Runtime is suggested to be 11 cycles. 
            </summary>
            <param name="input">The integer to hash.</param>
            <returns>The hashed result.</returns>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.hashString(`0)">
            <summary>
            Hashes a string using Bob Jenkin's "One At A Time" method from Dr. Dobbs (http://burtleburtle.net/bob/hash/doobs.html).
            Runtime is suggested to be 9x+9, where x = input.Length. 
            </summary>
            <param name="input">The string to hash.</param>
            <returns>The hashed result.</returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.EnlargeByteArray_BigEndian(System.Byte[],System.Int32)">
            <summary>
            Enlarges byte array till given size filling with 0 from start the rest of the length.
            Ex: byte[] a = new byte[] {1,2,3}; a.EnlargeByteArray_BigEndian(6) = new byte[] {0,0,0,1,2,3};
            If array for enlargement equals null new byte[size] will be returned, if array for enlargement length more or equal size then the same array will be returned.
            </summary>
            <param name="ar"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.EnlargeByteArray_LittleEndian(System.Byte[],System.Int32)">
            <summary>
            Enlarges byte array till given size filling with 0 after values of the supplied array.
            Ex: byte[] a = new byte[] {1,2,3}; a.EnlargeByteArray_LittleEndian(6) = new byte[] {1,2,3,0,0,0};
            If array for enlargement equals null new byte[size] will be returned, if array for enlargement length more or equal size then the same array will be returned.
            </summary>
            <param name="ar"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Substring(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Substring int-dimensional byte arrays
            </summary>
            <param name="ar"></param>
            <param name="startIndex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Substring(System.Byte[],System.Int32)">
            <summary>
            Substring int-dimensional byte arrays from and till the end
            </summary>
            <param name="ar"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CloneArray(System.Byte[])">
            <summary>
            Works only for int-dimesional arrays only
            </summary>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CopyInside(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies one array (source) into another (destination extension).
            <para>Destination array is taken as this</para>
            </summary>
            <param name="destArray"></param>
            <param name="destOffset"></param>
            <param name="srcArray"></param>
            <param name="srcOffset"></param>
            <param name="quantity"></param>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CopyInside(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Copies fully one array (source) into another (destination extension). Extra parameter destination offset.
            <para>Doesn't return anything, but changes destination array by reference.</para>
            <para>Can Throw exception if destArray.Length less then (destOffset + srcArray.Length)</para>
            <para>, for this use CopyInsideArrayCanGrow</para>
            </summary>
            <param name="destArray"></param>
            <param name="destOffset"></param>
            <param name="srcArray"></param>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CopyInsideArrayCanGrow(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Will return finally created array 
            <para>byte[] b = new byte[] { 1, 2, 3 };</para>
            <para>byte[] v = b.CopyInsideArrayCanGrow(1, new byte[] { 5, 6, 7 });</para>
            <para>will return v = byte[] { 1, 5, 6, 7 }</para>
            </summary>
            <param name="destArray"></param>
            <param name="destOffset"></param>
            <param name="srcArray"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.RemoveLeadingElement(System.Byte[],System.Byte)">
            <summary>
            Removes leading element from the array.
            Never returns null, but can return new byte[] {} (Length=0)
            </summary>
            <param name="array"></param>
            <param name="elementToRemove"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Reverse(System.Byte[])">
            <summary>
            Array.Reverse is the same fast, but reverses by reference the parameter-array, what is not acceptable
            </summary>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Concat(System.Byte[],System.Byte[])">
            <summary>
            Fastest Method. Works only for int-dimesional arrays only. 
            When necessary to concat many arrays use ConcatMany
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Concat(System.Byte,System.Byte)">
            <summary>
            FOR OPTIMITATION LIKE Concat(this byte[] ar1, byte ar2)
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Concat(System.Byte,System.Byte[])">
            <summary>
            FOR OPTIMITATION LIKE Concat(this byte[] ar1, byte ar2)
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ConcatMany(System.Byte[],System.Byte[][])">
            <summary>
            Fast when necessary to concat many arrays
            Example: byte[] s = new byte[] { 1, 2, 3 }; s.ConcatMany(new byte[] { 2, 3, 4 }, new byte[] { 3, 7, 8 }, new byte[] { 9, 10, 11 });
            Also: ((byte[])null).ConcatMany(new byte[] { 2, 3, 4 }, new byte[] { 3, 7, 8 }, new byte[] { 9, 10, 11 });
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ConcatMany(System.Byte[],System.Collections.Generic.IList{System.Byte[]})">
            <summary>
            Concats many byte arrays
            </summary>
            <param name="ar1"></param>
            <param name="arrays"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Concat(System.Collections.Generic.IList{System.Byte[]})">
            <summary>
            Concats all arrays into one byte[]
            </summary>
            <param name="arrays"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToIndex(System.Int32,System.Object[])">
            <summary>
            Concept of the objects storage (read docu from 20170321)
            Concatenates byte representing index and other elements, converted to byte[] using DBreeze converters, sequentially.
            </summary>
            <param name="indexNumber">Index number (one byte from 1-255)</param>
            <param name="pars">Parts of the index to be converted to byte[]</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToIndex(System.Byte,System.Object[])">
            <summary>
            Concept of the objects storage (read docu from 20170321)
            Concatenates byte representing index and other elements, converted to byte[] using DBreeze converters, sequentially.
            </summary>
            <param name="indexNumber">Index number (one byte from 1-255)</param>
            <param name="pars">Parts of the index to be converted to byte[]</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytes(System.Object[])">
            <summary>
            Concatenates converted to byte[] elements sequentially. 
            DBreeze converters are used.
            </summary>
            <param name="pars"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytes(System.Object,System.Object[])">
            <summary>
            Concatenates converted to byte[] elements sequentially. 
            DBreeze converters are used.
            </summary>
            <param name="par1"></param>
            <param name="pars"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.indexOfStringInByteArray(System.Byte[],System.String,System.Text.Encoding)">
            <summary>
            If not found returns -1
            </summary>
            <param name="ar"></param>
            <param name="search"></param>
            <param name="en"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IndexOfByteArray(System.Byte[],System.Byte[])">
            <summary>
            Searches Start index of the byte[] pattern inside of the byte array
            If not found returns -1
            </summary>
            <param name="ar"></param>
            <param name="search"></param>
            <param name="en"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Byte(System.Byte[])">
            <summary>
            From 1 byte array returns byte
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Byte_NULL(System.Byte[])">
            <summary>
            From 2 bytes array returns byte?
            If array length is not equal to 2 bytes returns null
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_DateTime(System.Byte[])">
            <summary>
            8-byte array tries to convert to DateTime
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_DateTime_zCompatibility(System.Byte[])">
            <summary>
            DON't use it (only for compatibility reasons described in docu from [20120922])
            BigEndian 8 bytes tries to convert to Ticks
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_DateTime_NULL(System.Byte[])">
            <summary>
            Returns DateTime? from 9-byte array
            If array is not equal 9 bytes returns null
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Bool_NULL(System.Byte[])">
            <summary>
            Returns bool? from 1-byte array
            if value length != 1 returns null.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Char(System.Byte[])">
            <summary>
            Converts 2 bytes byte[] into Unicode char
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Char_NULL(System.Byte[])">
            <summary>
            Converts 3 bytes byte[] into Unicode char?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_SByte(System.Byte[])">
            <summary>
            Converts 1 byte array into sbyte
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_SByte_NULL(System.Byte[])">
            <summary>
            Converts 2 bytes array into sbyte?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_BigEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in BigEndian order (highest byte first, lowest last) makes short.
            If array not equal 2 bytes throws exception. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_LittleEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in LittleEndian order (lowest byte first, highest last) makes short.
            If array not equal 2 bytes throws exception. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_BigEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in BigEndian order (highest byte first, lowest last) makes short?.
            If array not equal 3 bytes returns null. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in LittleEndian order (lowest byte first, highest last) makes short.
            If array not equal 3 bytes returns null. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_BigEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in BigEndian order (highest byte first, lowest last) makes ushort.
            If array not equal 2 bytes throws exception. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_LittleEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ushort.
            If array not equal 2 bytes throws exception. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_BigEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in BigEndian order (highest byte first, lowest last) makes ushort?.
            If array not equal 3 bytes returns null. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ushort?.
            If array not equal 3 bytes returns null. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_BigEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in BigEndian order (highest byte first, lowest last) makes int.
            If array not equal 4 bytes throws exception. (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_LittleEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in LittleEndian order (lowest byte first, highest last) makes int.
            If array not equal 4 bytes throws exception. (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_BigEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in BigEndian order (highest byte first, lowest last) makes int.
            If array is not equal 5 bytes returns null. Range is (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in LittleEndian order (lowest byte first, highest last) makes int.
            If array not equal 5 bytes returns null. (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_BigEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in BigEndian order (highest byte first, lowest last) makes uint.
            If array not equal 4 bytes throws exception. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_LittleEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in LittleEndian order (lowest byte first, highest last) makes uint.
            If array not equal 4 bytes throws exception. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_BigEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in BigEndian order (highest byte first, lowest last) makes uint?.
            If array not equal 5 bytes returns null. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in LittleEndian order (lowest byte first, highest last) makes uint?.
            If array not equal 5 bytes returns null. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_BigEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in BigEndian order (highest byte first, lowest last) makes long.
            If array not equal 8 bytes throws exception. (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_LittleEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in LittleEndian order (lowest byte first, highest last) makes long.
            If array not equal 8 bytes throws exception. (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_BigEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in BigEndian order (highest byte first, lowest last) makes long.
            If array not equal 9 bytes return null. Range (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in LittleEndian order (lowest byte first, highest last) makes long.
            If array not equal 9 bytes returns null. Range (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.DynamicLength_To_UInt64_BigEndian(System.Byte[])">
            <summary>
            From dynamic byte array (up to 8 bytes) stored in BigEndian format creates ulong value, 
            note if given byte array bigger then 8 bytes - then calcualtion will start from 0
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_BigEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in BigEndian order (highest byte first, lowest last) makes ulong.
            If array not equal 8 bytes throws exception. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_LittleEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ulong.
            If array not equal 8 bytes throws exception. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_BigEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in BigEndian order (highest byte first, lowest last) makes ulong?.
            If array is not equal 9 bytes returns null. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ulong?.
            If array is not equal 9 bytes returns null. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Decimal_BigEndian(System.Byte[])">
            <summary>
            Converts sortable byte[15] to decimal
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Decimal_BigEndian_NULL(System.Byte[])">
            <summary>
            Converts sortable byte[16] to decimal? if byte array length is not 16 returns null
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Double_BigEndian(System.Byte[])">
            <summary>
            Converts sortable byte[9] to double
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Double_BigEndian_NULL(System.Byte[])">
            <summary>
            Converts sortable byte[10] to double?
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Float_BigEndian(System.Byte[])">
            <summary>
            Converts sortable byte[4] to float
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Float_BigEndian_NULL(System.Byte[])">
            <summary>
            Converts sortable byte[5] to float?
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ByteArrayToDoubleArray(System.Byte[])">
            <summary>
            Converts double[] to byte[]. Reversed DoubleArrayToByteArray
            </summary>
            <param name="byteArray"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.DoubleArrayToByteArray(System.Double[])">
            <summary>
            Converts byte[] to double[]. Reversed ByteArrayToDoubleArray
            </summary>
            <param name="byteArray"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_byte_array(System.Nullable{System.Byte})">
            <summary>
            Returns 2 byte array which represents byte?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array(System.DateTime)">
            <summary>
            DateTime to byte[8] big-endian.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_zCompatibility(System.DateTime)">
            <summary>
            DON't use it (only for compatibility resasons described in docu from [20120922])
            DateTime to byte[8] big-endian.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array(System.Nullable{System.DateTime})">
            <summary>
            DateTime? to byte[9] big-endian.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_1_byte_array(System.Nullable{System.Boolean})">
            <summary>
            Returns 1 byte which represents bool?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_byte_array(System.Char)">
            <summary>
            Converts char into byte[2] Unicode representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_byte_array(System.Nullable{System.Char})">
            <summary>
            Converts char? into byte[3] Unicode representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_byte_array(System.Nullable{System.SByte})">
            <summary>
            Converts sbyte? into 2 byte array
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_BigEndian(System.Int16)">
            <summary>
            From Int16 to 2 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_LittleEndian(System.Int16)">
            <summary>
            From Int16 to 2 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_BigEndian(System.Nullable{System.Int16})">
            <summary>
            From Int16? to 3 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_LittleEndian(System.Nullable{System.Int16})">
            <summary>
            From Int16? to 3 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_BigEndian(System.UInt16)">
            <summary>
            From UInt16 to 2 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_LittleEndian(System.UInt16)">
            <summary>
            From UInt16 to 2 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_BigEndian(System.Nullable{System.UInt16})">
            <summary>
            From UInt16? to 3 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_LittleEndian(System.Nullable{System.UInt16})">
            <summary>
            From UInt16? to 3 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_BigEndian(System.Int32)">
            <summary>
            From Int32 to 4 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_LittleEndian(System.Int32)">
            <summary>
            From Int32 to 4 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_BigEndian(System.Nullable{System.Int32})">
            <summary>
            From Int32? to 5 bytes array with BigEndian order (highest byte first, lowest last).   
            When first byte is 0 then the whole value is NULL
            When first byte is 1 then value can be converted
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_LittleEndian(System.Nullable{System.Int32})">
            <summary>
            From Int32 to 4 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_BigEndian(System.UInt32)">
            <summary>
            From UInt32 to 4 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_LittleEndian(System.UInt32)">
            <summary>
            From UInt32 to 4 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_BigEndian(System.Nullable{System.UInt32})">
            <summary>
            From UInt32? to 5 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_LittleEndian(System.Nullable{System.UInt32})">
            <summary>
            From UInt32? to 5 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_BigEndian(System.Int64)">
            <summary>
            From Int64 to 8 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_LittleEndian(System.Int64)">
            <summary>
            From Int64 to 8 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_BigEndian(System.Nullable{System.Int64})">
            <summary>
            From Int64? to 9 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_LittleEndian(System.Nullable{System.Int64})">
            <summary>
            From Int64? to 9 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_BigEndian(System.UInt64)">
            <summary>
            From UInt64 to 8 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_LittleEndian(System.UInt64)">
            <summary>
            From UInt64 to 8 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_BigEndian(System.Nullable{System.UInt64})">
            <summary>
            From UInt64? to 9 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_LittleEndian(System.Nullable{System.UInt64})">
            <summary>
            From UInt64? to 9 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_15_bytes_array_BigEndian(System.Decimal)">
            <summary>
            Converts  decimal to sortable byte[15] 
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_16_bytes_array_BigEndian(System.Nullable{System.Decimal})">
            <summary>
            Converts  decimal? to sortable byte[16] 
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_BigEndian(System.Double)">
            <summary>
            Converts  double to sortable byte[9]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_10_bytes_array_BigEndian(System.Nullable{System.Double})">
            <summary>
            Converts double to sortable byte[10]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_BigEndian(System.Single)">
            <summary>
             Converts float to sortable byte[4]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_BigEndian(System.Nullable{System.Single})">
            <summary>
             Converts float? to sortable byte[5]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.TruncateUTF8(System.String,System.Int32)">
            <summary>
            Truncates UTF-8 strign up to special maxSizeInBytes due to UTF-8 specification. 
            </summary>
            <param name="text"></param>
            <param name="maxSizeInBytes"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_FixedSizeColumn(System.String,System.Int16,System.Boolean)">
            <summary>
            Converts your text into byte[], which can be used as column of fixedSize+2. 
            <para>(2 bytes are always added to your fixedSize value, determination of actual text size and NULL flag)</para>
            <para>String can be null</para>
            Will return byte[] with the length fixedSize+2 which can be stored as column.
            <para>If text.Length after convertion (using ASCII or UTF8) overexceeds fixedSize, text will be truncated</para>
            </summary>
            <param name="value">any string, can be NULL</param>
            <param name="fixedSize">reservation space(returned byte[] will be of fixedSize+2)</param>
            <param name="isASCII">if true, text will be presented as ASCII, otherwise as UTF-8</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.From_FixedSizeColumn(System.Byte[],System.Boolean)">
            <summary>
            takes byte[] created by To_FixedSizeColumn and restores string value from it.
            <para>byte[] must be of length fixedSize(which you gave in To_FixedSizeColumn) + 2</para>
            </summary>
            <param name="value"></param>
            <param name="isASCII">if true, text was presented as ASCII, otherwise as UTF-8</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBase64String(System.Byte[])">
            <summary>
            Creates a Base64string from byte array. Good for hashes.
            </summary>
            <param name="dBytes"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytesString(System.Byte[],System.String)">
            <summary>
            Converts BytesArray to String Representation: 00-00-00-00-1F-00-00-00-00-20.
            If array is null or 0 length - returns String.Empty.
            If replaceWith is String.Empty returns such view 00-00-00-00-1F-00-00-00-00-20.
            Otherwise takes such view (-00-00-00-00-1F-00-00-00-00-20) and replaces "-" with replaceWith also calls Trim().      
            </summary>
            <param name="dBytes"></param>
            <param name="replaceWith"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Utils.BytesProcessing._hexDigits">
            <summary>
            Used by ToBytesString
            </summary>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToByteArrayFromHex(System.String)">
            <summary>
            Generates byte[] from given Hex 1F0000000020. Backward function is ToHexFromByteArray
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToHexFromByteArray(System.Byte[])">
            <summary>
            Generates Hex 1F0000000020 from byte[]. Backward function is ToByteArrayFromHex/ToByteArrayFromHex
            </summary>
            <param name="dBytes"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytesString(System.Byte[])">
            <summary>
            To pure HEX string without delimiters
            </summary>
            <param name="dBytes"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToHex(System.Byte)">
            <summary>
            Convert Byte To Hex string
            </summary>
            <param name="dByte"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytesStringDec(System.Byte[],System.String)">
            <summary>
            Converts BytesArray to String Representation: 00-00-00-00-128-12-214-00-00-20.
            Where replaceWith = "-"
            </summary>
            <param name="dBytes"></param>
            <param name="replaceWith"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBitArray(System.Byte)">
            <summary>
            BigEndian
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Get_CRC16_AsByteArray(System.Byte[])">
            <summary>
            Returns byte representation of Crc16
            </summary>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoOneBitUp_NoArrayGrow_BigEndian(System.Byte[])">
            <summary>
            Adds byte[] + 1 bit.
            Returns: had {255}    -> null
            Returns: had {15,255} -> {16,0} 
            Returns: had {15,248} -> {15,249} 
            Returns: bt=null || bt.Length == 0 -> null
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoOneBitUp_ArrayGrows_BigEndian(System.Byte[])">
            <summary>
            Adds + 1 bit
            The same as BytesAction_GoOneBitUp_NoArrayGrow_BigEndian but array grows
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoOneBitDown_NoArrayGrow_BigEndian(System.Byte[])">
            <summary>
            Extracts 1 bit
            Returns: {0} -> null
            Returns: {0,0,0,0} -> null
            Returns: {254} -> {253}
            Returns: {1} -> {0}
            Returns: {121,456} -> {121,455}
            Returns: {121,0} -> {120,255}
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoUpNextByteStart_NoArrayGrow_BigEndian(System.Byte[],System.Int32)">
            <summary>
            <para>BytesAction_GoUpNextByteStart_NoArrayGrow_BigEndian</para>
            <para>Returns: had {255}    -> null</para>
            <para>Returns: had {255, 0} -> null</para>
            <para>Returns: bt=null || bt.Length less then 2  -> null</para>
            <para>Returns: had {254, 0} -> {255, 0}</para>
            <para>Returns: had {120, 115, 147} -> {120, 116, 0}</para>
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:DBreeze.Utils.BytesProcessing.BytesAction_GoDownNextByteStart_NoArrayGrow_BigEndian(System.Byte[],System.Int32)" -->
        <member name="M:DBreeze.Utils.BytesProcessing._Equals(System.Byte[],System.Byte[])">
            <summary>
            <para>USE _ByteArrayEquals</para>
            If both arrays are null, returns true. Checks nulls also. Uses SequenceEqual
            </summary>
            <param name="ar"></param>
            <param name="compareArray"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing._ByteArrayEquals(System.Byte[],System.Byte[])">
            <summary>
            Managed way compares 2 bytes array. Uses for loop and extra checks like null, length before
            </summary>
            <param name="b1"></param>
            <param name="b2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing._ByteArrayEquals_EqualityBrokenIndex(System.Byte[],System.Byte[])">
            <summary>
            Returns index where equality is broken.
            -2 if equal
            -1 if not comparable (null or so)
            </summary>
            <param name="b1"></param>
            <param name="b2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArraySmallerThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArraySmallerOrEqualThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArrayBiggerThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArrayBiggerOrEqualThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.ByteListComparer">
            <summary>
            Sorting of byte[]
             foreach (var r1 in input.OrderBy(x => x, new ByteListComparer())) Debug.WriteLine(r1.ToBytesString());
            </summary>
        </member>
        <member name="F:DBreeze.Utils.CustomSerializator.Serializator">
            <summary>
            Must be setup to be used together with DbCustomSerializer
            </summary>
        </member>
        <member name="F:DBreeze.Utils.CustomSerializator.Deserializator">
            <summary>
            Must be setup to be used together with DbCustomSerializer
            </summary>
        </member>
        <member name="F:DBreeze.Utils.CustomSerializator.ByteArraySerializator">
            <summary>
            Into byte array serializator can be supplied (Usually Protobuf.NET)
            </summary>
        </member>
        <member name="F:DBreeze.Utils.CustomSerializator.ByteArrayDeSerializator">
            <summary>
            From byte[] deserializator can be used (Usually Protobuf.NET)
            </summary>
        </member>
        <member name="M:DBreeze.Utils.CustomSerializator.SerializeCustom(System.Object)">
            <summary>
            Serializes object to JSON from Microsoft
            </summary>
            <param name="objectForSerialization"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.CustomSerializator.DeserializeCustom``1(System.String)">
            <summary>
            Deserializes object from Microsoft JSON string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.DbReaderWriterLock">
            <summary>
            Wrapper For System.Threading.ReaderWriterLockSlim
            In case if better algorithm will be found
            </summary>
        </member>
        <member name="T:DBreeze.Utils.DbReaderWriterSpinLock">
            <summary>
            Temporar wrapper
            </summary>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.#ctor">
            <summary>
            Creates open Gate
            </summary>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.PutGateHere">
            <summary>
            Sets Gate in the code
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.PutGateHere(System.Int32)">
            <summary>
            If gate is closed then it will be closed timeout time in milliseconds
            </summary>
            <param name="milliseconds"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Hash.MurMurHash.MixedMurMurHash3_128(System.Byte[])">
            <summary>
            128 bit mixed MurMurhash3
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Hash.MurMurHash.MixedMurMurHash3_64(System.Byte[])">
            <summary>
            64 bit mixed MurMurhash3
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Hash.MurMurHash.MurmurHash3(System.Byte[],System.UInt32)">
            <summary>
            32 bit
            </summary>
            <param name="data"></param>
            <param name="seed"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.StringProcessing">
            <summary>
            Set of string processing extensions
            </summary>
        </member>
        <member name="M:DBreeze.Utils.StringProcessing.To_AsciiBytes(System.String)">
            <summary>
            Encoding.ASCII.GetBytes
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.StringProcessing.To_UTF8Bytes(System.String)">
            <summary>
            Encoding.UTF8.GetBytes
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.StringProcessing.To_UnicodeBytes(System.String)">
            <summary>
            Encoding.Unicode.GetBytes
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.StringProcessing.UTF8_GetString(System.Byte[])">
            <summary>
            UTF8.GetString
            </summary>
            <param name="btText"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.StringProcessing.Unicode_GetString(System.Byte[])">
            <summary>
            Unicode.GetString
            </summary>
            <param name="btText"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.StringProcessing.Ascii_GetString(System.Byte[])">
            <summary>
            ASCII.GetString
            </summary>
            <param name="btText"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.StringProcessing.ReplaceMultiple(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            <para>Will efficiently replace multiple string by supplied templates.</para>
            var replacements = new Dictionary&lt;string, string&gt;()
            {
              {"big","hot"},
              {"mac","dog"}
            };       
            </summary>
            <param name="input"></param>
            <param name="replaceWith"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.XmlSerializator.SerializeXml(System.Collections.Generic.List{System.String})">
            <summary>
            Serializes object to XML string
            </summary>
            <param name="objectForSerialization"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.XmlSerializator.DeserializeXml``1(System.String)">
            <summary>
            Deserializes object from XML string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Compression.GZip_Compress(System.Byte[])">
            <summary>
            In Memory Compression with Gzip
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Compression.GZip_Decompress(System.Byte[])">
            <summary>
            In Memory GZip Decompressor. Fastest implementation at the moment
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.Biser">
            <summary>
            Custom binary serializer of well known types
            </summary>
        </member>
        <member name="M:DBreeze.Utils.Biser.GetVarintBytes(System.UInt64)">
            <summary>
            Uses protobuf concepts
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.ToTarget(System.Byte[],System.Int32)">
            <summary>
            ToTarget
            </summary>
            <param name="bytes"></param>
            <param name="sizeBites"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Encode_DICT_PROTO_STRING_BYTEARRAYHASHSET(System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.List{System.Byte[]}},DBreeze.Utils.Compression.eCompressionMethod)">
            <summary>
            Proto encoding of Dictionary [string, List[byte[]]].
            Hashset can be null, after decoding istantiated, zero-length hashset will be returned in this case.
            </summary>
            <param name="d"></param>
            <param name="compression"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decode_DICT_PROTO_STRING_BYTEARRAYHASHSET(System.Byte[],System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.List{System.Byte[]}},DBreeze.Utils.Compression.eCompressionMethod)">
            <summary>
            Decodes byte[] into  Dictionary [string, List[byte[]]]
            </summary>
            <param name="encB"></param>
            <param name="retD"></param>
            <param name="compression"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Encode_DICT_PROTO_STRING_UINTHASHSET(System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.HashSet{System.UInt32}},DBreeze.Utils.Compression.eCompressionMethod)">
            <summary>
            Proto encoding of Dictionary [string, HashSet[uint]].
            Hashset can be null, after decoding istantiated, zero-length hashset will be returned in this case.
            </summary>
            <param name="d"></param>
            <param name="compression"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decode_DICT_PROTO_STRING_UINTHASHSET(System.Byte[],System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.HashSet{System.UInt32}},DBreeze.Utils.Compression.eCompressionMethod)">
            <summary>
            Decodes byte[] into  Dictionary [string, HashSet[uint]]
            </summary>
            <param name="encB"></param>
            <param name="retD"></param>
            <param name="compression"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Encode_DICT_PROTO_UINT_BYTEARRAY(System.Collections.Generic.IDictionary{System.UInt32,System.Byte[]},DBreeze.Utils.Compression.eCompressionMethod)">
            <summary>
            Proto encoding of Dictionary [uint, byte[]].
            Use when key is less then 4 bytes (less then 268mln).
            Value byte[0] will be presented as null after decoding
            </summary>
            <param name="d"></param>
            <param name="compression">compression method extra applied to the outgoing byte array</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decode_DICT_PROTO_UINT_BYTEARRAY(System.Byte[],System.Collections.Generic.IDictionary{System.UInt32,System.Byte[]},DBreeze.Utils.Compression.eCompressionMethod)">
            <summary>
            Used when parameter is encoded with Encode_DICT_PROTO_UINT_BYTEARRAY.
            Returns Dictionary [uint, byte[]]
            </summary>
            <param name="encB"></param>
            <param name="retD">Instantiated Dictionary must be supplied and will be returned filled</param>        
            <param name="compression">compression method supplied by Encode_DICT_PROTO_UINT_BYTEARRAY</param>
        </member>
        <member name="M:DBreeze.Utils.Biser.Encode_PROTO_ListByteArray(System.Collections.Generic.IList{System.Byte[]})">
            <summary>
            null elements equal to new byte[0]
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decode_PROTO_ListByteArray(System.Byte[])">
            <summary>
            null elements equal to new byte[0]
            </summary>
            <param name="encB"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.GetVarintBytes(System.UInt32)">
            <summary>
            Returns the specified 32-bit unsigned value as varint encoded array of bytes.
            Uses protobuf concepts
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.GetVarintBytes(System.Int64)">
            <summary>
            Returns the specified 64-bit signed value as varint encoded array of bytes.   
            </summary>
            <param name="value">64-bit signed value</param>
            <returns>Varint array of bytes.</returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.ToUInt32(System.Byte[])">
            <summary>
            Uses protobuf concepts
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.Biser.Decoder">
            <summary>
            Biser.Decoder
            </summary>
        </member>
        <member name="F:DBreeze.Utils.Biser.Decoder.qb">
            <summary>
            Quantity of bytes needed to form latest varint
            </summary>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decoder.#ctor(System.Byte[])">
            <summary>
            
            </summary>
            <param name="encoded"></param>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decoder.CheckNull">
            <summary>
            Is used for checking next collection on null, before getting one of the itterators.
            </summary>
            <returns>true if null</returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decoder.GetCollection(System.Boolean)">
            <summary>
            Universal, but a bit slower (because of the yield returns) than those ones with IDictionary or IList
            </summary>
            <param name="isNullChecked"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decoder.GetCollection``1(System.Func{``0},System.Collections.Generic.IList{``0},System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="K"></typeparam>
            <param name="fk"></param>
            <param name="lst"></param>
            <param name="isNullChecked"></param>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decoder.GetCollection``2(System.Func{``0},System.Func{``1},System.Collections.Generic.IDictionary{``0,``1},System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="fk"></param>
            <param name="fv"></param>
            <param name="dict"></param>
            <param name="isNullChecked"></param>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decoder.JSGetLong">
            <summary>
             Javascript Biser decoder
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decoder.JSGetString">
            <summary>
            Javascript Biser decoder
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.Decoder.JSGetDouble">
            <summary>
             Javascript Biser decoder
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.Biser.Encoder">
            <summary>
            Biser.Encoder
            </summary>
        </member>
        <member name="T:DBreeze.Utils.Biser.JsonDecoder">
            <summary>
            Biser JSON decoder
            </summary>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonDecoder.SkipValue">
            <summary>
            Must be used as a default call, while analyzing Dictionary key or the Class property
            </summary>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonDecoder.SkipDelimiter">
            <summary>
            Skips :
            </summary>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonDecoder.GetDictionary``1(System.Boolean)">
            <summary>
            Returns Key, Value must be retrieved extra
            </summary>
            <typeparam name="K">Dictionary Key type</typeparam>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.Biser.JsonEncoder">
            <summary>
            Biser JSON Encoder
            </summary>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonEncoder.Add(System.String,System.Collections.Generic.Dictionary{System.String,System.Action})">
            <summary>
            To supply heterogen values inside of Dictionary
            </summary>
            <typeparam name="V"></typeparam>
            <param name="propertyName"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonEncoder.Add(System.Collections.Generic.Dictionary{System.String,System.Action})">
            <summary>
            To supply heterogen values inside of Dictionary
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonEncoder.Add(System.String,System.Collections.Generic.List{System.Action})">
            <summary>
            Supplies heterogonenous array elements
            </summary>
            <param name="propertyName"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonEncoder.Add(System.Collections.Generic.List{System.Action})">
            <summary>
             Supplies heterogonenous array elements
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonEncoder.Add``2(System.String,System.Collections.Generic.IDictionary{``0,``1},System.Action{``1})">
            <summary>
            Adds Dictionary each Key will be transformed into String
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="propertyName"></param>
            <param name="val"></param>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonEncoder.Add``2(System.Collections.Generic.IDictionary{``0,``1},System.Action{``1})">
            <summary>
             Adds Dictionary each Key will be transformed into String
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            <param name="val"></param>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonEncoder.Add(System.String,DBreeze.Utils.Biser.IJsonEncoder)">
            <summary>
            Adds class implementing IJsonEncoder
            </summary>
            <param name="propertyName"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonEncoder.Add``1(System.String,System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Supply array and transformation function, one for each array element
            </summary>
            <typeparam name="T"></typeparam>
            <param name="propertyName"></param>
            <param name="val"></param>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Biser.JsonEncoder.Add``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
             Supply array and transformation function, one for each array element
            </summary>
            <typeparam name="T"></typeparam>
            <param name="val"></param>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.Biser.JsonSettings">
            <summary>
            JsonSettings
            </summary>
        </member>
        <member name="F:DBreeze.Utils.Biser.JsonSettings.DateTimeStyle.Default">
            <summary>
            Default /Date(...)/
            </summary>
        </member>
        <member name="F:DBreeze.Utils.Biser.JsonSettings.DateTimeStyle.ISO">
            <summary>
            ISO Format: "2018-06-05T17:44:15.4430000Z" or "2018-06-05T17:44:15.4430000+02:00"
            </summary>
        </member>
        <member name="F:DBreeze.Utils.Biser.JsonSettings.DateTimeStyle.EpochTime">
            <summary>
            Unix Epoch Milliseconds. Fastest for both operations
            </summary>
        </member>
        <member name="F:DBreeze.Utils.Biser.JsonSettings.DateTimeStyle.Javascript">
            <summary>
            Each local time must be converted into UTC and then represented as ISO
            </summary>
        </member>
        <member name="T:DBreeze.Utils.DeepCopyByExpressionTrees">
            <summary>
            Superfast deep copier class, which uses Expression trees.
            </summary>
        </member>
        <member name="M:DBreeze.Utils.DeepCopyByExpressionTrees.DeepCopyByExpressionTree``1(``0,System.Collections.Generic.Dictionary{System.Object,System.Object})">
            <summary>
            Creates a deep copy of an object.
            </summary>
            <typeparam name="T">Object type.</typeparam>
            <param name="original">Object to copy.</param>
            <param name="copiedReferencesDict">Dictionary of already copied objects (Keys: original objects, Values: their copies).</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.DeepCopyByExpressionTrees.CloneByExpressionTree``1(``0,System.Collections.Generic.Dictionary{System.Object,System.Object})">
            <summary>
            Creates a deep copy of an object (Works 3 times faster than ProtobufClone).
            </summary>
            <typeparam name="T">Object type.</typeparam>
            <param name="original">Object to copy.</param>
            <param name="copiedReferencesDict">Dictionary of already copied objects (Keys: original objects, Values: their copies).</param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.FastRandom">
             <summary>
             A fast random number generator for .NET, from https://www.codeproject.com/Articles/9187/A-fast-equivalent-for-System-Random
             Colin Green, January 2005
            
             September 4th 2005
            	 Added NextBytesUnsafe() - commented out by default.
            	 Fixed bug in Reinitialise() - y,z and w variables were not being reset.
            
             Key points:
              1) Based on a simple and fast xor-shift pseudo random number generator (RNG) specified in:
              Marsaglia, George. (2003). Xorshift RNGs.
              http://www.jstatsoft.org/v08/i14/xorshift.pdf
            
              This particular implementation of xorshift has a period of 2^128-1. See the above paper to see
              how this can be easily extened if you need a longer period. At the time of writing I could find no
              information on the period of System.Random for comparison.
            
              2) Faster than System.Random. Up to 8x faster, depending on which methods are called.
            
              3) Direct replacement for System.Random. This class implements all of the methods that System.Random
              does plus some additional methods. The like named methods are functionally equivalent.
            
              4) Allows fast re-initialisation with a seed, unlike System.Random which accepts a seed at construction
              time which then executes a relatively expensive initialisation routine. This provides a vast speed improvement
              if you need to reset the pseudo-random number sequence many times, e.g. if you want to re-generate the same
              sequence many times. An alternative might be to cache random numbers in an array, but that approach is limited
              by memory capacity and the fact that you may also want a large number of different sequences cached. Each sequence
              can each be represented by a single seed value (int) when using FastRandom.
            
              Notes.
              A further performance improvement can be obtained by declaring local variables as static, thus avoiding
              re-allocation of variables on each call. However care should be taken if multiple instances of
              FastRandom are in use or if being used in a multi-threaded environment.
            
             </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.#ctor">
            <summary>
            Initialises a new instance using time dependent seed.
            </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.#ctor(System.Int32)">
            <summary>
            Initialises a new instance using an int value as seed.
            This constructor signature is provided to maintain compatibility with
            System.Random
            </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.Reinitialise(System.Int32)">
            <summary>
            Reinitialises using an int value as a seed.
            </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.Next">
             <summary>
             Generates a random int over the range 0 to int.MaxValue-1.
             MaxValue is not generated in order to remain functionally equivalent to System.Random.Next().
             This does slightly eat into some of the performance gain over System.Random, but not much.
             For better performance see:
            
             Call NextInt() for an int over the range 0 to int.MaxValue.
            
             Call NextUInt() and cast the result to an int to generate an int over the full Int32 value range
             including negative values.
             </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.Next(System.Int32)">
            <summary>
            Generates a random int over the range 0 to upperBound-1, and not including upperBound.
            </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.Next(System.Int32,System.Int32)">
            <summary>
            Generates a random int over the range lowerBound to upperBound-1, and not including upperBound.
            upperBound must be >= lowerBound. lowerBound may be negative.
            </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.NextDouble">
            <summary>
            Generates a random double. Values returned are from 0.0 up to but not including 1.0.
            </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.NextFloat">
            <summary>
            Generates a random double. Values returned are from 0.0 up to but not including 1.0.
            </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the provided byte array with random bytes.
            This method is functionally equivalent to System.Random.NextBytes().
            </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.NextUInt">
             <summary>
             Generates a uint. Values returned are over the full range of a uint,
             uint.MinValue to uint.MaxValue, inclusive.
            
             This is the fastest method for generating a single random number because the underlying
             random number generator algorithm generates 32 random bits that can be cast directly to
             a uint.
             </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.NextInt">
             <summary>
             Generates a random int over the range 0 to int.MaxValue, inclusive.
             This method differs from Next() only in that the range is 0 to int.MaxValue
             and not 0 to int.MaxValue-1.
            
             The slight difference in range means this method is slightly faster than Next()
             but is not functionally equivalent to System.Random.Next().
             </summary>
        </member>
        <member name="M:DBreeze.Utils.FastRandom.NextBool">
            <summary>
            Generates a single random bit.
            This method's performance is improved by generating 32 bits in one operation and storing them
            ready for future calls.
            </summary>
        </member>
        <member name="T:DBreeze.Utils.MultiKeyDictionary">
            <summary>
            Once added dimension must stay. 
            mkd.Add("dsfs", 17L, "key2");
            mkd.Add(new List&lt;string&gt;{ "w1", "w2" }, 11L, "key22");
            var mkdRes = mkd.Get&lt;string&gt;(17L, "key2");
            var mkdResBool1 = mkd.TryGetValue&lt;List&lt;string&gt;&gt;(out var dder1, 11L, "key22");
            </summary>
        </member>
        <member name="F:DBreeze.Utils.MultiKeyDictionary.ByteArraySerializator">
            <summary>
            External Serializer for MultiKeyDictionary
            </summary>
        </member>
        <member name="F:DBreeze.Utils.MultiKeyDictionary.ByteArrayDeSerializator">
            <summary>
            External deserializer for MultiKeyDictionary
            </summary>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary.CreateDeconstructDelegate``1(System.Int32,System.Type,System.Func{System.Collections.Generic.List{System.Object},``0}@)">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary.get_type_flds(System.Type)">
            <summary>
            
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.MultiKeyDictionary`2">
            <summary>
            MultiKeyDictionary where key is a Tuple with more than one key.
            Second generation of the non-generic MKD, supporting cloning, serialization, count and named returns due to the ValueTuple behaviour.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="F:DBreeze.Utils.MultiKeyDictionary`2.Sync">
            <summary>
            Sync object. Not instantiated
            </summary>
        </member>
        <member name="F:DBreeze.Utils.MultiKeyDictionary`2.Count">
            <summary>
            Total count of elements in MKD
            </summary>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.CloneMultiKeyDictionary">
            <summary>
            Clones this multi-key dictionary into another instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.Add(`0,`1)">
            <summary>
            Adds elements
            </summary>
            <param name="keys"></param>
            <param name="value"></param>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.Serialize">
            <summary>
            MultiKeyDictionary.ByteArraySerializator must be set (once for all instances)
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.Deserialize(System.Byte[])">
            <summary>
            MultiKeyDictionary.ByteArrayDeSerializator must be set (once for all instances)
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.GetAll">
            <summary>
            Iterate over all elements of the dictionary
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:DBreeze.Utils.MultiKeyDictionary`2.GetByKeyStart(System.Object[])" -->
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.GetRecursByKeyStart(System.Collections.Generic.Dictionary{System.Object,System.Object},System.Int32,System.Collections.Generic.List{System.Object},System.Object[])">
            <summary>
            
            </summary>
            <param name="di"></param>
            <param name="dim"></param>
            <param name="l"></param>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.GetRecurs(System.Collections.Generic.Dictionary{System.Object,System.Object},System.Int32,System.Collections.Generic.List{System.Object})">
            <summary>
            
            </summary>
            <param name="di"></param>
            <param name="dim"></param>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.Contains(`0)">
            <summary>
            
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.Remove(`0)">
            <summary>
            Removes key completely
            </summary>
            <param name="keys"></param>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.Remove(System.Object[])">
            <summary>
            Remove support deleting starting from key (if dimension is 3 then 3, 2 or 1 key can be supplied). To remove all use Clear()
            </summary>
            <param name="keys"></param>
        </member>
        <member name="P:DBreeze.Utils.MultiKeyDictionary`2.Item(`0)">
            <summary>
            Gets/Sets the value by complete Key
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.Get(`0)">
            <summary>
            Gets the value by complete Key
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value by the complete key
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeyDictionary`2.TryGetValue``1(``0@,System.Object[])">
            <summary>
            Internal dimensions are checked level up
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.MultiKeySortedDictionary`2">
            <summary>
            MultiKeySortedDictionary where key is a Tuple with more than one key
            Second generation of the non-generic MKD, supporting cloning, serialization, count and named returns due to the ValueTuple behaviour.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.#ctor">
            <summary>
            MultiKeySortedDictionary
            </summary>
        </member>
        <member name="F:DBreeze.Utils.MultiKeySortedDictionary`2.Sync">
            <summary>
            Sync object. Not instantiated
            </summary>
        </member>
        <member name="F:DBreeze.Utils.MultiKeySortedDictionary`2.Count">
            <summary>
            Total count of elements in MKD
            </summary>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.Serialize">
            <summary>
            MultiKeyDictionary.ByteArraySerializator must be set (once for all instances)
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.Deserialize(System.Byte[])">
            <summary>
            MultiKeyDictionary.ByteArrayDeSerializator must be set (once for all instances)
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.CloneMultiKeySortedDictionary">
            <summary>
            Clones this multi-key dictionary into another instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.Add(`0,`1)">
            <summary>
            Adds elements
            </summary>
            <param name="keys"></param>
            <param name="value"></param>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.GetAll">
            <summary>
            Iterate over all elements of the dictionary
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.GetAllObj">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:DBreeze.Utils.MultiKeySortedDictionary`2.GetByKeyStart(System.Object[])" -->
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.GetRecursByKeyStart(System.Collections.Generic.SortedDictionary{System.Object,System.Object},System.Int32,System.Collections.Generic.List{System.Object},System.Object[])">
            <summary>
            
            </summary>
            <param name="di"></param>
            <param name="dim"></param>
            <param name="l"></param>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.GetRecurs(System.Collections.Generic.SortedDictionary{System.Object,System.Object},System.Int32,System.Collections.Generic.List{System.Object})">
            <summary>
            
            </summary>
            <param name="di"></param>
            <param name="dim"></param>
            <param name="l"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.Contains(`0)">
            <summary>
            
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.Remove(`0)">
            <summary>
            Removes key completely
            </summary>
            <param name="keys"></param>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.Remove(System.Object[])">
            <summary>
            Remove support deleting starting from key (if dimension is 3 then 3, 2 or 1 key can be supplied). To remove all use Clear()
            </summary>
            <param name="keys"></param>
        </member>
        <member name="P:DBreeze.Utils.MultiKeySortedDictionary`2.Item(`0)">
            <summary>
            Gets/Sets the value by complete Key
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.Get(`0)">
            <summary>
            Gets the value by complete Key
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value by the complete key
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.MultiKeySortedDictionary`2.TryGetValue``1(``0@,System.Object[])">
            <summary>
            Internal dimensions are checked level up
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.HNSW.CosineDistance">
             <summary>
             Calculates cosine similarity.
             </summary>
             <remarks>
             Intuition behind selecting float as a carrier.
            
             1. In practice we work with vectors of dimensionality 100 and each component has value in range [-1; 1]
                There certainly is a possibility of underflow.
                But we assume that such cases are rare and we can rely on such underflow losses.
            
             2. According to the article http://www.ti3.tuhh.de/paper/rump/JeaRu13.pdf
                the floating point rounding error is less then 100 * 2^-24 * sqrt(100) * sqrt(100) &lt; 0.0005960
                We deem such precision is satisfactory for out needs.
             </remarks>
        </member>
        <member name="M:DBreeze.HNSW.CosineDistance.DistanceForUnitsSimple(System.Single[],System.Single[])">
            <summary>
            Calculates cosine distance with assumption that u and v are unit vectors.
            </summary>
            <param name="u">Left vector.</param>
            <param name="v">Right vector.</param>
            <returns>Cosine distance between u and v.</returns>
        </member>
        <member name="M:DBreeze.HNSW.CosineDistance.NormalizeSimple(System.Single[])">
            <summary>
            Turns vector to unit vector.
            </summary>
            <param name="vector">The vector to normalize.</param>
        </member>
        <member name="M:DBreeze.HNSW.CosineDistance.NormalizeVector(System.Double[])">
            <summary>
            Normalize vector
            </summary>
            <param name="vector"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.HNSW.BinaryHeap`1">
            <summary>
            Binary heap wrapper around the <see cref="T:System.Collections.Generic.IList`1"/>
            It's a max-heap implementation i.e. the maximum element is always on top.
            But the order of elements can be customized by providing <see cref="T:System.Collections.Generic.IComparer`1"/> instance.
            </summary>
            <typeparam name="T">The type of the items in the source list.</typeparam>
        </member>
        <member name="M:DBreeze.HNSW.BinaryHeap`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:DBreeze.HNSW.BinaryHeap`1"/> class.
            </summary>
            <param name="buffer">The buffer to store heap items.</param>
        </member>
        <member name="M:DBreeze.HNSW.BinaryHeap`1.#ctor(System.Collections.Generic.List{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:DBreeze.HNSW.BinaryHeap`1"/> class.
            </summary>
            <param name="buffer">The buffer to store heap items.</param>
            <param name="comparer">The comparer which defines order of items.</param>
        </member>
        <member name="P:DBreeze.HNSW.BinaryHeap`1.Comparer">
            <summary>
            Gets the heap comparer.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.BinaryHeap`1.Buffer">
            <summary>
            Gets the buffer of the heap.
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.BinaryHeap`1.Push(`0)">
            <summary>
            Pushes item to the heap.
            </summary>
            <param name="item">The item to push.</param>
        </member>
        <member name="M:DBreeze.HNSW.BinaryHeap`1.Pop">
            <summary>
            Pops the item from the heap.
            </summary>
            <returns>The popped item.</returns>
        </member>
        <member name="M:DBreeze.HNSW.BinaryHeap`1.SiftDown(System.Int32)">
            <summary>
            Restores the heap property starting from i'th position down to the bottom
            given that the downstream items fulfill the rule.
            </summary>
            <param name="i">The position of item where heap property is violated.</param>
        </member>
        <member name="M:DBreeze.HNSW.BinaryHeap`1.SiftUp(System.Int32)">
            <summary>
            Restores the heap property starting from i'th position up to the head
            given that the upstream items fulfill the rule.
            </summary>
            <param name="i">The position of item where heap property is violated.</param>
        </member>
        <member name="M:DBreeze.HNSW.BinaryHeap`1.Swap(System.Int32,System.Int32)">
            <summary>
            Swaps items with the specified indicies.
            </summary>
            <param name="i">The first index.</param>
            <param name="j">The second index.</param>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2">
            <summary>
            <see href="https://arxiv.org/abs/1603.09320">Hierarchical Navigable Small World Graphs</see>.
            </summary>
            <typeparam name="TItem">The type of items to connect into small world.</typeparam>
            <typeparam name="TDistance">The type of distance between items (expect any numeric type: float, double, decimal, int, ...).</typeparam>
            <summary>
            <see href="https://arxiv.org/abs/1603.09320">Hierarchical Navigable Small World Graphs</see>.
            </summary>
            <typeparam name="TItem">The type of items to connect into small world.</typeparam>
            <typeparam name="TDistance">The type of distance between items (expect any numeric type: float, double, decimal, int, ...).</typeparam>
            <content>
            The part with the implemenation of a hierarchical small world graph.
            </content>
            <content>
            The part with the implementaion of a node in the hnsw graph.
            </content>
            <content>
            The part with the auxiliary tools for hnsw algorithm.
            </content>
        </member>
        <member name="F:DBreeze.HNSW.SmallWorld`2.Composer.GetVectorbyExternalId">
            <summary>
            Function to get embeddings from outer table by ExternalId.
            In case if it is NULL, we also Adding vectors inside Storage.TableVectors
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Composer.KNNSearch(`0,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="k"></param>
            <param name="clearDistanceCache"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Composer.Count">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.InstanceManager">
            <summary>
            
            </summary>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.CInstance">
            <summary>
            
            </summary>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.BucketManager">
            <summary>
            
            </summary>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.DistanceCache`1">
            <summary>
            
            </summary>
            <typeparam name="TDistance"></typeparam>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.DistanceCache`1.Mkd">
            <summary>
            Gets or sets Mkd.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.DistanceCache`1.Count">
            <summary>
            Gets or Sets Count.
            </summary>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.NodeCache">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.NodeCache.Flush">
            <summary>
            
            </summary>
            <returns>true if something was changed</returns>
        </member>
        <member name="F:DBreeze.HNSW.SmallWorld`2.distance">
            <summary>
            The distance function in the items space.
            </summary>
        </member>
        <member name="F:DBreeze.HNSW.SmallWorld`2.graph">
            <summary>
            The hierarchical small world graph instance.
            </summary>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.NeighbourSelectionHeuristic">
            <summary>
            Type of heuristic to select best neighbours for a node.
            </summary>
        </member>
        <member name="F:DBreeze.HNSW.SmallWorld`2.NeighbourSelectionHeuristic.SelectSimple">
            <summary>
            Marker for the Algorithm 3 (SELECT-NEIGHBORS-SIMPLE) from the article.
            Implemented in <see cref="T:DBreeze.HNSW.SmallWorld`2.NodeAlg3"/>
            </summary>
        </member>
        <member name="F:DBreeze.HNSW.SmallWorld`2.NeighbourSelectionHeuristic.SelectHeuristic">
            <summary>
            Marker for the Algorithm 4 (SELECT-NEIGHBORS-HEURISTIC) from the article.
            Implemented in <see cref="T:DBreeze.HNSW.SmallWorld`2.NodeAlg4"/>
            </summary>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.Parameters">
            <summary>
            Parameters of the algorithm.
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Parameters.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DBreeze.HNSW.SmallWorld`2.Parameters"/> class.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Parameters.M">
            <summary>
            Gets or sets the parameter which defines the maximum number of neighbors in the zero and above-zero layers.
            The maximum number of neighbors for the zero layer is 2 * M.
            The maximum number of neighbors for higher layers is M.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Parameters.LevelLambda">
            <summary>
            Gets or sets the max level decay parameter.
            https://en.wikipedia.org/wiki/Exponential_distribution
            See 'mL' parameter in the HNSW article.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Parameters.NeighbourHeuristic">
            <summary>
            Gets or sets parameter which specifies the type of heuristic to use for best neighbours selection.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Parameters.ConstructionPruning">
            <summary>
            Gets or sets the number of candidates to consider as neighbousr for a given node at the graph construction phase.
            See 'efConstruction' parameter in the article.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Parameters.ExpandBestSelection">
            <summary>
            Gets or sets a value indicating whether to expand candidates if <see cref="F:DBreeze.HNSW.SmallWorld`2.NeighbourSelectionHeuristic.SelectHeuristic"/> is used.
            See 'extendCandidates' parameter in the article.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Parameters.KeepPrunedConnections">
            <summary>
            Gets or sets a value indicating whether to keep pruned candidates if <see cref="F:DBreeze.HNSW.SmallWorld`2.NeighbourSelectionHeuristic.SelectHeuristic"/> is used.
            See 'keepPrunedConnections' parameter in the article.
            </summary>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.KNNSearchResult">
            <summary>
            Representation of knn search result.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.KNNSearchResult.Id">
            <summary>
            Gets or sets the id of the item = rank of the item in source collection.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.KNNSearchResult.Item">
            <summary>
            Gets or sets the item itself.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.KNNSearchResult.Distance">
            <summary>
            Gets or sets the distance between the item and the knn search query.
            </summary>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.Graph">
            <summary>
            The layered graph implementation.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Graph.Parameters">
            <summary>
            Gets parameters of the algorithm.
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Graph.#ctor(DBreeze.HNSW.SmallWorld{`0,`1}.Parameters)">
            <summary>
            Initializes a new instance of the <see cref="T:DBreeze.HNSW.SmallWorld`2.Graph"/> class.
            </summary>            
            <param name="parameters">The parameters of the algorithm.</param>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Graph.NewNode">
            <summary>
            Gets the node factory associated with the graph.
            The node construction arguments are:
            1st: int -> the id of the new node;
            2nd: TItem -> the item to attach to the node;
            3rd: int -> the level of the node.
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Graph.AddItems(System.Collections.Generic.IList{System.ValueTuple{System.Int64,`0}},System.Boolean)">
            <summary>
            
            </summary>
            <param name="items"></param>
            <param name="clearDistanceCache"></param>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Graph.KNearest(DBreeze.HNSW.SmallWorld{`0,`1}.Node,System.Int32)">
            <summary>
            Get k nearest items for a given one.
            Contains implementation of K-NN-SEARCH(hnsw, q, K, ef) algorithm.
            Article: Section 4. Algorithm 5.
            </summary>
            <param name="destination">The given node to get the nearest neighbourhood for.</param>
            <param name="k">The size of the neighbourhood.</param>
            <returns>The list of the nearest neighbours.</returns>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Graph.KNearestAtLevel(DBreeze.HNSW.SmallWorld{`0,`1}.Node,DBreeze.HNSW.SmallWorld{`0,`1}.Node,System.Int32,System.Int32)">
            <summary>
            The implementaiton of SEARCH-LAYER(q, ep, ef, lc) algorithm.
            Article: Section 4. Algorithm 2.
            </summary>
            <param name="entryPoint">The entry point for the search.</param>
            <param name="destination">The search target.</param>
            <param name="k">The number of the nearest neighbours to get from the layer.</param>
            <param name="level">Level of the layer.</param>
            <returns>The list of the nearest neighbours at the level.</returns>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Graph.RandomLevel(DBreeze.Utils.FastRandom,System.Double)">
            <summary>
            Gets the level for the layer.
            </summary>
            <param name="generator">The random numbers generator.</param>
            <param name="lambda">Poisson lambda.</param>
            <returns>The level value.</returns>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.Node">
            <summary>
            The abstract node implementation.
            The <see cref="!:SelectBestForConnecting(IList&lt;Node&gt;)"/> must be implemented by the subclass.
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Node.#ctor(System.Int32,System.Int64,`0,System.Int32,DBreeze.HNSW.SmallWorld{`0,`1}.Graph,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:DBreeze.HNSW.SmallWorld`2.Node"/> class.
            </summary>
            <param name="id">The identifier of the node.</param>
            <param name="item">The item which is represented by the node.</param>
            <param name="maxLevel">The maximum level until which the node exists.</param>
            <param name="distance">The distance function for attached items.</param>
            <param name="parameters">The parameters of the algorithm.</param>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Node.Id">
            <summary>
            Gets the identifier of the node.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Node.ExternalId">
            <summary>
            Gets the external identifier of the item.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Node.MaxLevel">
            <summary>
            Gets the maximum level of the node.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Node.TempItem">
            <summary>
            Needed for the knn-search, for the query the Node is also created
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Node.Item">
            <summary>
            Gets the item associated with the node.
            </summary>
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.Node.Connections">
            <summary>
            Gets all connections of the node on all layers.
            </summary>            
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Node.AddConnection(DBreeze.HNSW.SmallWorld{`0,`1}.Node,System.Int32)">
            <summary>
            Add connections to the node on the specific layer.
            </summary>
            <param name="newNeighbour">The node to connect with.</param>
            <param name="level">The level of the layer.</param>           
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Node.SelectBestForConnecting(System.Collections.Generic.List{DBreeze.HNSW.SmallWorld{`0,`1}.Node})">
            <summary>
            The algorithm which selects best neighbours from the candidates for this node.
            </summary>
            <param name="candidates">The candidates for connecting.</param>
            <returns>Best nodes selected from the candidates.</returns>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.Node.GetM(System.Int32,System.Int32)">
            <summary>
            Get maximum allowed connections for the given layer.
            </summary>
            <remarks>
            Article: Section 4.1:
            "Selection of the Mmax0 (the maximum number of connections that an element can have in the zero layer) also
            has a strong influence on the search performance, especially in case of high quality(high recall) search.
            Simulations show that setting Mmax0 to M(this corresponds to kNN graphs on each layer if the neighbors
            selection heuristic is not used) leads to a very strong performance penalty at high recall.
            Simulations also suggest that 2∙M is a good choice for Mmax0;
            setting the parameter higher leads to performance degradation and excessive memory usage".
            </remarks>
            <param name="baseM">Base M parameter of the algorithm.</param>
            <param name="level">The level of the layer.</param>
            <returns>The maximum number of connections.</returns>
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.NodeAlg3">
            <summary>
            The implementation of the SELECT-NEIGHBORS-SIMPLE(q, C, M) algorithm.
            Article: Section 4. Algorithm 3.
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.NodeAlg3.#ctor(System.Int32,System.Int64,`0,System.Int32,DBreeze.HNSW.SmallWorld{`0,`1}.Graph,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:DBreeze.HNSW.SmallWorld`2.NodeAlg3"/> class.
            </summary>
            <param name="id">The identifier of the node.</param>
            <param name="item">The item which is represented by the node.</param>
            <param name="maxLevel">The maximum level until which the node exists.</param>
            <param name="distance">The distance function for attached items.</param>
            <param name="parameters">The parameters of the algorithm.</param>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.NodeAlg3.SelectBestForConnecting(System.Collections.Generic.List{DBreeze.HNSW.SmallWorld{`0,`1}.Node})">
            <inheritdoc />
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.NodeAlg4">
            <summary>
            The implementation of the SELECT-NEIGHBORS-HEURISTIC(q, C, M, lc, extendCandidates, keepPrunedConnections) algorithm.
            Article: Section 4. Algorithm 4.
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.NodeAlg4.#ctor(System.Int32,System.Int64,`0,System.Int32,DBreeze.HNSW.SmallWorld{`0,`1}.Graph,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:DBreeze.HNSW.SmallWorld`2.NodeAlg4"/> class.
            </summary>
            <param name="id">The identifier of the node.</param>
            <param name="item">The item which is represented by the node.</param>
            <param name="maxLevel">The maximum level until which the node exists.</param>
            <param name="distance">The distance function for attached items.</param>
            <param name="parameters">The parameters of the algorithm.</param>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.NodeAlg4.SelectBestForConnecting(System.Collections.Generic.List{DBreeze.HNSW.SmallWorld{`0,`1}.Node})">
            <inheritdoc />
        </member>
        <member name="P:DBreeze.HNSW.SmallWorld`2.DBStorage.TableName">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.DBStorage.FlushNodes(System.Int32,System.Collections.Generic.Dictionary{System.Int32,DBreeze.HNSW.SmallWorld{`0,`1}.Node})">
            <summary>
            true, if something was saved
            </summary>
            <param name="bucketId"></param>
            <param name="nodes"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.SmallWorldStorageF.AddItem(System.Int64,System.Int32,System.Int32,System.Single[])">
            <summary>
            item should be already normalized
            </summary>
            <param name="externalId"></param>
            <param name="bucketId"></param>
            <param name="id"></param>
            <param name="item"></param>           
        </member>
        <member name="T:DBreeze.HNSW.SmallWorld`2.SmallWorldStorageD">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.SmallWorldStorageD.AddItem(System.Int64,System.Int32,System.Int32,System.Double[])">
            <summary>
            item should be already normalized
            </summary>
            <param name="externalId"></param>
            <param name="bucketId"></param>
            <param name="id"></param>
            <param name="item"></param>           
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.DLt(`1,`1)">
            <summary>
            Distance is Lower Than.
            </summary>
            <param name="x">Left argument.</param>
            <param name="y">Right argument.</param>
            <returns>True if x &lt; y.</returns>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.DGt(`1,`1)">
            <summary>
            Distance is Greater Than.
            </summary>
            <param name="x">Left argument.</param>
            <param name="y">Right argument.</param>
            <returns>True if x &gt; y.</returns>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.DEq(`1,`1)">
            <summary>
            Distances are Equal.
            </summary>
            <param name="x">Left argument.</param>
            <param name="y">Right argument.</param>
            <returns>True if x == y.</returns>
        </member>
        <member name="M:DBreeze.HNSW.SmallWorld`2.BFS(DBreeze.HNSW.SmallWorld{`0,`1}.Node,System.Int32,System.Action{DBreeze.HNSW.SmallWorld{`0,`1}.Node})">
            <summary>
            Runs breadth first search.
            </summary>
            <param name="entryPoint">The entry point.</param>
            <param name="level">The level of the graph where to run BFS.</param>
            <param name="visitAction">The action to perform on each node.</param>
        </member>
        <member name="T:DBreeze.HNSW.ReverseComparer`1">
            <summary>
            Reverses the order of the nested comparer.
            </summary>
            <typeparam name="T">The types of items to comapre.</typeparam>
        </member>
        <member name="F:DBreeze.HNSW.ReverseComparer`1.Default">
            <summary>
            Gets a default sort order comparer for the type specified by the generic argument.
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.ReverseComparer`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:DBreeze.HNSW.ReverseComparer`1"/> class.
            </summary>
            <param name="comparer">The comparer to invert.</param>
        </member>
        <member name="M:DBreeze.HNSW.ReverseComparer`1.Compare(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:DBreeze.HNSW.ReverseComparerExtensions">
            <summary>
            Extension methods to shortcut <see cref="T:DBreeze.HNSW.ReverseComparer`1"/> usage.
            </summary>
        </member>
        <member name="M:DBreeze.HNSW.ReverseComparerExtensions.Reverse``1(System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates new <see cref="T:DBreeze.HNSW.ReverseComparer`1"/> wrapper for the given comparer.
            </summary>
            <typeparam name="T">The types of items to comapre.</typeparam>
            <param name="comparer">The source comparer.</param>
            <returns>The inverted to source comparer.</returns>
        </member>
        <member name="M:DBreeze.HNSW.VectorTran.InitForTableD``1(System.String,DBreeze.Transactions.Transaction.VectorTableParameters{System.Double[]})">
            <summary>
            
            </summary>
            <typeparam name="TVector"></typeparam>
            <param name="tableName"></param>
            <param name="vectorTableParameters"></param>
        </member>
        <member name="P:DBreeze.DBreezeConfiguration.Backup">
            <summary>
            Incremental backup plan. If is not instantiated, incremental backup will be switch off
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeConfiguration.DBreezeDataFolderName">
            <summary>
            Folder where will reside DBreeze database files
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.eStorage.RemoteInstance">
            <summary>
            In case if database files are located on a remote host
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeConfiguration.Storage">
            <summary>
            DISK, MEMORY or Remote Instance. DEFAULT IS DISK,
            DBreezeDataFolderName must be supplied.
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.AlternativeTablesLocations">
            <summary>
            Pattern based way to specify storage and location for tables.
            <para>Key of this dictionary must contain table pattern e.g. Article$/Items# or Car456 or Items*</para>
            <para>Value, if is String.Empty, means that table will be located in memory.</para>
            <para>Value, if not empty, means physical storage folder path, where table should reside.</para>
            <para>If table doesn't intersect any pattern then default DB configuration will be overriden for the storage.</para>
            <para>If table intersects more the one pattern then first found will be applied.</para>
            <para>Help for patterns:</para>
            <para>$ * #</para>
            <para>"U" symbol in the following examples means intersection</para>
            <para>* - 1 or more of any symbol kind (every symbol after * will be cutted): Items* U Items123/Pictures</para>
            <para># - symbols (except slash) followed by slash and minimum another symbol: Items#/Picture U Items123/Picture</para>
            <para>$ - 1 or more symbols except slash (every symbol after $ will be cutted): Items$ U Items123;  Items$ !U Items123/Pictures </para>
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.RICommunicator">
            <summary>
            In case if we want to use storage layer RemoteInstance (RISR), this must be supplied.
            Answers for sending data to Remote Acceptor and returning answer back
            </summary>
        </member>
        <member name="T:DBreeze.DBreezeConfiguration.TextSearchConfiguration">
            <summary>
            Configuration concerning TextSearch subsystem
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.TextSearchConfiguration.QuantityOfWordsInBlock">
            <summary>
            Search Index setting. Less value - bigger index on the disc, and faster search.
            More RAM is used
            <para>Mobile recommendations year 2015: 100</para>
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.TextSearchConfiguration.MinimalBlockReservInBytes">
            <summary>
            Search Index setting. Reservation block growth size
            <para>Mobile recommendations year 2015: 1000</para>
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.TextSearchConfiguration.MaximalWordSize">
            <summary>
            Maximal word size separated by the space. Default is 50 symbols
            </summary>
        </member>
        <member name="T:DBreeze.DBreezeConfiguration.VectorlayerConfiguration">
            <summary>
            Configuration concerning Vector layer
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.VectorlayerConfiguration.Dense">
            <summary>
             Default 1000. Quantity of vectors/centroids per Graph Edge, when reached splits Edge on EdgeVectorsQuantity/Dense bringing their new centroids on the upper Edge within the Graph.
             <para>Min 50, Max 5000.</para>
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.TextSearchConfig">
            <summary>
            Configuration concerning TextSearch subsystem
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.NotifyAhead_WhenWriteTablePossibleDeadlock">
            <summary>
            Default is true. On the early stage helps the programmers to put a modifying table into the transaction.SynchronizeTables statement.
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.VectorLayerConfig">
            <summary>
            Configuration 
            </summary>
        </member>
        <member name="T:DBreeze.DBreezeResources">
            <summary>
            DBreeze resources represents an In-Memory dictionary synchronized with an internal DBreeze table. 
            Key is a string, Value any standard DBreeze.DataType (or serialized object, when custom serializer is supplied).
            Can be called from anywhere, even from other transactions. There is no need to add into sync table
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeResources._urp">
            <summary>
            UserResourcePrefix. Having prefixes gives us ability to reuse the table for smth. else
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeResources.#ctor(DBreeze.DBreezeEngine)">
            <summary>
            constructor
            </summary>
            <param name="engine"></param>
        </member>
        <member name="M:DBreeze.DBreezeResources.Dispose">
            <summary>
            Disposing
            </summary>
        </member>
        <member name="T:DBreeze.DBreezeResources.Settings">
            <summary>
            Settings regulating resources behaviour
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeResources.Settings.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeResources.Settings.HoldInMemory">
            <summary>
            Resource will be stored in-memory, for the fast access.
            Default is true
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeResources.Settings.HoldOnDisk">
            <summary>
            Resource will be stored on-disk
            Default is true
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeResources.Settings.FastUpdates">
            <summary>            
            Sets OverWriteIsAllowed = false.
            Toggle only if it's not enough the speed of the update.
            Default is false.
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeResources.Settings.InsertWithVerification">
            <summary>
            Prevents disk insert of the identical value of the existing key.
            Is interesting in case of intensive writes.
            Default is true.
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeResources.Settings.SortingAscending">
            <summary>
            Needed for getting resources via SelectStartsWith.
            Default is true.
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeResources.Insert``1(System.String,``0,DBreeze.DBreezeResources.Settings)">
            <summary>
            Insert resource
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="resourceName"></param>
            <param name="resourceObject"></param>
            <param name="resourceSettings">resource extra behaviour</param>        
        </member>
        <member name="M:DBreeze.DBreezeResources.Insert``1(System.Collections.Generic.IDictionary{System.String,``0},DBreeze.DBreezeResources.Settings)">
            <summary>
            Batch insert of resources where value is a defined DBreeze or DBreeze.CustomSerializer type
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="resources"></param>
            <param name="resourceSettings"></param>
        </member>
        <member name="M:DBreeze.DBreezeResources.Insert(System.Collections.Generic.IDictionary{System.String,System.Byte[]},DBreeze.DBreezeResources.Settings)">
            <summary>
            Batch insert of resources where value is a byte[]
            </summary>
            <param name="resources"></param>
            <param name="resourceSettings">resource extra behaviour</param>
        </member>
        <member name="M:DBreeze.DBreezeResources.Remove(System.Collections.Generic.IList{System.String})">
            <summary>
            Removes resources from database and In-Memory dictionary 
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeResources.Remove(System.String)">
            <summary>
            Removes resource from database and 
            </summary>        
        </member>
        <member name="M:DBreeze.DBreezeResources.SelectStartsWith``1(System.String,DBreeze.DBreezeResources.Settings)">
            <summary>
            SelectStartsWith.
            Value instance, when byte[], must stay immutable, please use Dbreeze.Utils.CloneArray
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="resourceNameStartsWith"></param>
            <param name="resourceSettings"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DBreezeResources.Select``1(System.Collections.Generic.IList{System.String},DBreeze.DBreezeResources.Settings)">
            <summary>
            Gets resources of the same type as a batch from memory or database (if not yet loaded).
            Value instance, when byte[], must stay immutable, please use Dbreeze.Utils.CloneArray
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="resourcesNames"></param>
            <param name="resourceSettings">resource extra behaviour</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DBreezeResources.Select``1(System.String,DBreeze.DBreezeResources.Settings)">
            <summary>
            Gets resource from memory or database (if not yet loaded)
            Value instance, when byte[], must stay immutable, please use Dbreeze.Utils.CloneArray
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="resourceName"></param>
            <param name="resourceSettings">resource extra behaviour</param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Scheme.AutoCloseOpenTables">
            <summary>
            Flag that closes file of the table if threads don't use it for reading or writing.
            </summary>
        </member>
        <member name="M:DBreeze.Scheme.GetPhysicalPathToTheUserTable(System.String)">
            <summary>
            ONLY FOR INTERNAL NEEDS, lock must be handeled by outer procedure.
            Users must use GetTablePathFromTableName.
            Transactions Journal after start will try to delete RollbackFiles of the finished transactions.
            For this it needs to know exact pathes.
            For now all tables stored in one folder. Later we will have extra config file which lets to reside 
            some of tables in the other folders. 
            This function is an access globalizer to physical file locations by userTableName.
            !!!!TRAnJRNL, WHEN RESTORES ROLLBACK, MUST REFER TO Scheme trie settings in the future, FOR NOW DEFAULT
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetTablePathFromTableName(System.String)">
            <summary>
            Returns physical path to the table file, if table doesn't exists in the Scheme returns String.Empty
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetUserTableNameAsByte(System.String)">
            <summary>
            Adds static prefix to all user table names, to
            make selection of tables for different purposes easier with StartsWith function
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetTable(System.String)">
            <summary>
            Returns table for READ, WRITE FUNC
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.CheckAlternativeTableLocationsIntersections(System.String,System.String@)">
            <summary>
            Checks if in configuration was supplied alternative path for table location.
            Returns true if intersection was found.
            Alternative Path equals to String.Empty - locate in Memory
            </summary>
            <param name="userTableName"></param>
            <param name="alternativePath"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.CloseTables(System.Collections.Generic.Dictionary{System.String,System.Nullable{System.UInt64}})">
            <summary>
            Called by Transaction, when it's time to be Disposed and close tables.
            Tables will be closed only in case of other threads don't use it.
            </summary>
            <param name="closeOpenTables"></param>
        </member>
        <member name="M:DBreeze.Scheme.DeleteAllReleatedTableFiles(System.String)">
            <summary>
            Used by GetTableFor Write, if table is newly created and we have such file name
            </summary>
            <param name="fullTableFilePath"></param>
        </member>
        <member name="M:DBreeze.Scheme.IfUserTableExists(System.String)">
            <summary>
            Returns if user table exists
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetUserTableNamesStartingWith(System.String)">
            <summary>
            Returns List of user tables starting from specified mask.
            If mask is String.Empty returns all user tables
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.DeleteTable(System.String)">
            <summary>
            Deletes user table
            </summary>
            <param name="userTableName"></param>
        </member>
        <member name="M:DBreeze.Scheme.RenameTable(System.String,System.String)">
            <summary>
            Renames user table, if it existed.
            <para>Safe, will make operation only when other threads stop to work with the oldTable</para>
            </summary>
            <param name="oldUserTableName"></param>
            <param name="newUserTableName"></param>
        </member>
        <member name="M:DBreeze.Scheme.RenameTableInternal(System.String,System.String)">
            <summary>
            Renames user table, if it existed.
            <para>If there are threads which are working with this table, rename will not be finished and will return false</para>
            </summary>
            <param name="oldUserTableName"></param>
            <param name="newUserTableName"></param>
            <returns>true if successfully renamed, otherwise false</returns>
        </member>
        <member name="T:DBreeze.Objects.DBreezeIndex">
            <summary>
            Concept of the objects storage (read docu from 20170321)
            </summary>
        </member>
        <member name="F:DBreeze.Objects.DBreezeIndex.IndexNumber">
            <summary>
            Must be unique for every index, will be used for searches
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeIndex.AddPrimaryToTheEnd">
            <summary>
            Only for not primary index
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeIndex.PrimaryIndex">
            <summary>
            Set a flag that this index is a primary key
            </summary>
        </member>
        <member name="M:DBreeze.Objects.DBreezeIndex.#ctor(System.Byte,System.Object[])">
            <summary>
            
            </summary>
            <param name="indexNumber">Must be unique for every index, will be used for searches</param>
            <param name="props">chain of data types forming byte[] index. if null is supplied existing index entry will be removed</param>
        </member>
        <member name="M:DBreeze.Objects.DBreezeIndex.FormIndex(System.Byte[])">
            <summary>
            
            </summary>
            <param name="primaryIdx"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Objects.DBreezeObject`1">
            <summary>
            Concept of the objects storage (read docu from 20170321)
            </summary>
            <typeparam name="TEntityType"></typeparam>
        </member>
        <member name="M:DBreeze.Objects.DBreezeObject`1.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeObject`1.Indexes">
            <summary>
            List of indexes
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeObject`1.NewEntity">
            <summary>
            Deafult false. Skips reading existing value on the disk (insert time economy)
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeObject`1.Entity">
            <summary>
            Entity itself
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeObject`1.ExisingEntity">
            <summary>
            If existing entity was taken before it can be supplied to speed up insert process
            by skipping reading value from new.
            Existing object must be taken from row
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeObject`1.IncludeOldEntityIntoResult">
            <summary>
            Default false. If true updated value will be included into DBreezeObjectInsertResult.OldEntity
            </summary>
        </member>
        <member name="T:DBreeze.Objects.DBreezeObjectInsertResult`1">
            <summary>
            Concept of the objects storage (read docu from 20170321)
            Answer after transaction.ObjectInsert
            </summary>
            <typeparam name="TEntityType"></typeparam>
        </member>
        <member name="M:DBreeze.Objects.DBreezeObjectInsertResult`1.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeObjectInsertResult`1.OldEntityWasFound">
            <summary>
            Indicates that old entity exists
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeObjectInsertResult`1.OldEntity">
            <summary>
            Entity which was found in database before update.
            Will be included if DBreezeObject.IncludeOldEntityIntoResult = true;
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeObjectInsertResult`1.EntityWasInserted">
            <summary>
            In case if entity was inserted is set to true
            </summary>
        </member>
        <member name="P:DBreeze.Objects.DBreezeObjectInsertResult`1.PtrToObject">
            <summary>
            Pointer to DBreezeObject, ObjectGetByFixedAddress should help to retrieve it.
            </summary>
        </member>
        <member name="T:DBreeze.TextSearch.BlockAnd">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.BlockAnd.#ctor(System.String,System.String)">
            <summary>
            Generates a logical block: 
            var tsm = tran.TextSearch("MyTextSearchTable");
            tsm.BlockAnd("pill").OR(new DBreeze.TextSearch.BlockAnd("blue", "#LNDDE"))
            .GetDocumentIDs
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>
        </member>
        <member name="T:DBreeze.TextSearch.BlockOr">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.BlockOr.#ctor(System.String,System.String)">
            <summary>
            Generates a logical block: 
            var tsm = tran.TextSearch("MyTextSearchTable");
            tsm.BlockAnd("pill").OR(new DBreeze.TextSearch.BlockOr("blue red", "#LNDDE"))
            .GetDocumentIDs
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>
        </member>
        <member name="T:DBreeze.TextSearch.SBlock">
            <summary>
            Text search block
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock.eOperation.AND">
            <summary>
            Possible in and between blocks
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock.eOperation.OR">
            <summary>
            Possible in and between blocks
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock.eOperation.XOR">
            <summary>
            Possible only between blocks
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock.eOperation.EXCLUDE">
            <summary>
            Possible only between blocks
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock.Ignored">
            <summary>
            Block will not be counted in intersection calculations if has empty FullMatch and Contains words
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock._tsm">
            <summary>
            TextSearchManager
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock.ParsedWords">
            <summary>
            Word, fullMatch  
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock.BlockId">
            <summary>
            
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock.IsLogicalBlock">
            <summary>
            This block is a result of operation between 2 other blocks.
            False is a pure block added via TextSearchManager
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock.InternalBlockOperation">
            <summary>
            Internal in-block operation between words.
            Generation-term
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.SBlock.foundArrays">
            <summary>
            Generation-term
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.And(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Adding new logical block (And or Or, depending upon parameter blockAnd)
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>
            <param name="blockAnd">default value is true, indicating and block</param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.Or(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Adding new logical block (And or Or, depending upon parameter blockAnd)
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>
            <param name="blockAnd">default value is true, indicating and block</param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.Xor(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Adding new logical block (And or Or, depending upon parameter blockAnd)
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>
            <param name="blockAnd">default value is true, indicating and block</param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.Exclude(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Adding new logical block (And or Or, depending upon parameter blockAnd)
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>
            <param name="blockAnd">default value is true, indicating and block</param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.And(DBreeze.TextSearch.SBlock,System.Boolean)">
            <summary>
            Returns last added block. Can be added existing block or new block in format
            new DBreeze.TextSearch.BlockAnd(... or new DBreeze.TextSearch.BlockOr(
            </summary>
            <param name="block"></param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.Or(DBreeze.TextSearch.SBlock,System.Boolean)">
            <summary>
            Returns last added block. Can be added existing block or new block in format
            new DBreeze.TextSearch.BlockAnd(... or new DBreeze.TextSearch.BlockOr(
            </summary>
            <param name="block"></param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.Xor(DBreeze.TextSearch.SBlock,System.Boolean)">
            <summary>
            Returns last added block. Can be added existing block or new block in format
            new DBreeze.TextSearch.BlockAnd(... or new DBreeze.TextSearch.BlockOr(
            </summary>
            <param name="block"></param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.Exclude(DBreeze.TextSearch.SBlock,System.Boolean)">
            <summary>
            Returns last added block. Can be added existing block or new block in format
            new DBreeze.TextSearch.BlockAnd(... or new DBreeze.TextSearch.BlockOr(
            </summary>
            <param name="block"></param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.GetDocumentIDs">
            <summary>
            IEnumerable returning External GetDocumentIDs
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.GetArrays">
            <summary>
            Universal function resulting final one/many arrays (in AND) and one array in (OR, XOR, EXCLUDE)
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.SBlock.GetPureBlockArrays">
            <summary>
            Fills up foundArrays for the current block. If logic is And and word is not found can clear already array on that level.
            Concenrs only pure (not logical) blocks
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.TextSearch.TextDeferredIndexer">
            <summary>
            TextDeferredIndexer
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.TextDeferredIndexer.Dispose">
            <summary>
            Disposing
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.TextDeferredIndexer.Add(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.HashSet{System.UInt32}})">
            <summary>
            Add tables and their InternalDocumentIDs for paraller indexing of the Text Engine
            </summary>
            <param name="defferedDocIds"></param>
        </member>
        <member name="M:DBreeze.TextSearch.TextDeferredIndexer.AddVectors(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.HashSet{System.UInt32}})">
            <summary>
            Add tables and their InternalDocumentIDs for paraller indexing of the Vector Engine, protocol 0,0
            </summary>
            <param name="defferedDocIds"></param>
        </member>
        <member name="M:DBreeze.TextSearch.TextDeferredIndexer.StartDefferedIndexing">
            <summary>
            Runs Indexer. Only one instance is allowed
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.TextDeferredIndexer.Indexer">
            <summary>
            Indexer self
            </summary>
        </member>
        <member name="T:DBreeze.TextSearch.TextSearchHandler">
            <summary>
            New instance per transaction. Is created by necessity, while inserting or selecting anything concerning TextSearch subsystem.
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchHandler.DeferredVectors">
            <summary>
            TextSearch handler becomes universal for other entites
            </summary>
        </member>
        <member name="T:DBreeze.TextSearch.TextSearchHandler.ITS">
            <summary>
            Internal search-table structure.       
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchHandler.ITS.e2i">
            <summary>
            External document index to internal - 1. Key byte[], Value int
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchHandler.ITS.i2e">
            <summary>
            Internal document index to external - 2. Key int, Value byte[]
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchHandler.ITS.srch">
            <summary>
            Searchables to insert - 3. internal docId(int)+ new byte[]{0}/new byte[]{1} (0 for current searchables, 1 for new intended to be saved searchables), Value is searchables.
            Insert always compares newly intended with current and if no changes exits. 
            Indexer replaces new with current.
            itbls.Value.ChangedDocIds contains IDs of changed docs per search table
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchHandler.ITS.blocks">
            <summary>
            Key 10: [uint,byte[]] where K is BlockID[uint] (1000 words per block), Value is GzippedAndProtobufed Dictionary of [uint, byte[]] where K is ID of the word in Key2 and value its WAH reserved (init reservation 100KB per block)            
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchHandler.ITS.currentBlock">
            <summary>
            Key 11: [int] - current blockNumber
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchHandler.ITS.numberInBlock">
            <summary>
            Key 12: [int] used number in the block
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchHandler.ITS.words">
            <summary>
            Key 20 : [string,byte[]] NestedTable(Index to search by words)
            <para>Where Key: string - word</para>
            <para>Value: [byte[]] BlockId[uint] + NumberInBlock[uint] (reference to Key 10)</para>
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchHandler.itbls">
            <summary>
            Registering all search-tables mutated during transaction
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchHandler.GetDocumentsSearchables(DBreeze.Transactions.Transaction,System.String,System.Collections.Generic.HashSet{System.Byte[]})">
            <summary>
            
            </summary>
            <param name="tran"></param>
            <param name="tableName"></param>
            <param name="documentIDs"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchHandler.InsertDocumentText(DBreeze.Transactions.Transaction,System.String,System.Byte[],System.String,System.String,System.Boolean,System.Int32,DBreeze.TextSearch.TextSearchHandler.eInsertMode)">
            <summary>
            
            </summary>
            <param name="tran"></param>
            <param name="tableName"></param>
            <param name="documentId"></param>
            <param name="containsWords"></param>
            <param name="fullMatchWords"></param>
            <param name="deferredIndexing"></param>
            <param name="containsMinimalLength"></param>
            <param name="iMode"></param>
        </member>
        <member name="P:DBreeze.TextSearch.TextSearchHandler.WordInDocs.BlockId">
            <summary>
            Wah2 block id
            </summary>
        </member>
        <member name="P:DBreeze.TextSearch.TextSearchHandler.WordInDocs.NumberInBlock">
            <summary>
            Number in Wah2 block
            </summary>
        </member>
        <member name="P:DBreeze.TextSearch.TextSearchHandler.WordInDocs.Processed">
            <summary>
            Processed
            </summary>
        </member>
        <member name="P:DBreeze.TextSearch.TextSearchHandler.WordInDocs.wahArray">
            <summary>
            Unzipped WABI
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchHandler.BeforeCommit">
            <summary>
            Started only in case if InsertWasPerformed in deffered or not deffered way
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchHandler.AfterCommit">
            <summary>
             Started only in case if InsertWasPerformed in deffered or not deffered way
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchHandler.DoIndexing(DBreeze.Transactions.Transaction,System.Collections.Generic.Dictionary{System.String,DBreeze.TextSearch.TextSearchHandler.ITS})">
            <summary>
            itbls and transaction must be supplied, to make it working from outside
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchHandler.WordsDiff(System.Byte[],System.Byte[])">
            <summary>
            This function accepts old value of searchables for one document and new value,
            decides what must be Removed (par1) and what should be Added (par2)
            </summary>
            <param name="oldtext"></param>
            <param name="newtext"></param>
            <returns>List 2remove, List 2add</returns>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchHandler.GetByteArrayFromSearchbles(System.String)">
            <summary>
            Converter from searchbales to byte[]
            </summary>
            <param name="searchables"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchHandler.GetSearchablesFromByteArray(System.Byte[])">
            <summary>
            Converter from byte[] searchables.
            </summary>
            <param name="searchables"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchHandler.GetSearchablesFromByteArray_AsHashSet(System.Byte[])">
            <summary>
            
            </summary>
            <param name="searchables"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.TextSearch.TextSearchHandler.WordDefinition">
            <summary>
            
            </summary>        
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchHandler.GetWordsDefinitionFromText(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Returns null in case of notfound anything or what ever
            </summary>
            <param name="containsWords"></param>
            <param name="fullMatchWords"></param>
            <param name="containsMinimalLength"></param>
            <param name="maxWordSize">Taken from configuration. Default is 50. word separated by spaces</param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.TextSearch.TextSearchTable">
            <summary>
            Manager for word aligned bitmap indexes
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchTable._tran">
            <summary>
            
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchTable.NoisyQuantity">
            <summary>
            Default value is 1000
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchTable.SearchCriteriaIsNoisy">
            <summary>
            
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchTable.ExternalDocumentIdStart">
            <summary>
            If not null limits the search range of the documents.
            ExternalDocumentID will be converted into InternalID and will be used as a ranges start
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchTable.ExternalDocumentIdStop">
            <summary>
            If not null limits the search range of the documents.
            ExternalDocumentID will be converted into InternalID and will be used as a ranges stop
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchTable.Descending">
            <summary>
            Default found documents will be returned descending (last added document first)
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchTable.DocIdA">
            <summary>
            Converted ExternalDocumentIdStart
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchTable.DocIdZ">
            <summary>
            Converted ExternalDocumentIdStop
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchTable.PureWords">
            <summary>
            Second preparation layer after parsing. After this layer we grab words from db and put into real words
            </summary>
        </member>
        <member name="F:DBreeze.TextSearch.TextSearchTable.PureWordDef.StartsWith">
            <summary>
            In case if word must be searched using contains logic in db can be StartsWith echoes
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchTable.#ctor(DBreeze.Transactions.Transaction,System.String)">
            <summary>
            
            </summary>
            <param name="tran"></param>
            <param name="tableName"></param>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchTable.ComputeWordsOrigin">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchTable.Block(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Generates a logical block: 
            var tsm = tran.TextSearch("MyTextSearchTable");
            tsm.Block("choose").And(new DBreeze.TextSearch.BlockAnd("pill")).Or(tsm.BlockOr("blue red"))
            .GetDocumentIDs
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic or startswith if words were stored by full-match logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>
            <param name="blockAnd">default value is true, indicating BlockAnd</param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchTable.BlockAnd(System.String,System.String,System.Boolean)">
            <summary>
            Generates a logical block: 
            var tsm = tran.TextSearch("MyTextSearchTable");
            tsm.Block("choose").And(new DBreeze.TextSearch.BlockAnd("pill")).Or(tsm.BlockOr("blue red"))
            .GetDocumentIDs
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>   
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchTable.BlockAnd(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Generates a logical block: 
            var tsm = tran.TextSearch("MyTextSearchTable");
            tsm.Block("choose").And(new DBreeze.TextSearch.BlockAnd("pill")).Or(tsm.BlockOr("blue red"))
            .GetDocumentIDs
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic or startswith if words were stored by full-match logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchTable.BlockOr(System.String,System.String,System.Boolean)">
            <summary>
            Generates a logical block: 
            var tsm = tran.TextSearch("MyTextSearchTable");
            tsm.Block("choose").And(new DBreeze.TextSearch.BlockAnd("pill")).Or(tsm.BlockOr("blue red"))
            .GetDocumentIDs
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic or startswith if words were stored by full-match logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchTable.BlockOr(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Generates a logical block: 
            var tsm = tran.TextSearch("MyTextSearchTable");
            tsm.Block("choose").And(new DBreeze.TextSearch.BlockAnd("pill")).Or(tsm.BlockOr("blue red"))
            .GetDocumentIDs
            </summary>
            <param name="containsWords">space separated words to be used by "contains" logic</param>
            <param name="fullMatchWords">space separated words to be used by "full-match" logic</param>
            <param name="ignoreOnEmptyParameters">Block will not be counted in intersection calculations if has empty FullMatch and Contains words</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.TextSearchTable.WordsPrepare(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Collections.Generic.Dictionary{System.String,System.Boolean}@)">
            <summary>
            
            </summary>
            <param name="searchKeywords"></param>
            <param name="fullMatch"></param>
            <param name="wordsList"></param>
        </member>
        <member name="T:DBreeze.TextSearch.WABI">
            <summary>
            Word aligned bitmap index
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.#ctor(System.Byte[])">
            <summary>
            Must be supplied CompressedByteArray taken from GetCompressedByteArray function
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.GetUncompressedByteArray">
            <summary>
            Working byte[]
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.GetCompressedByteArray">
            <summary>
            With extra protocol definition, ready for save into DB
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.Add(System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.Resize(System.Int32)">
            <summary>
            
            </summary>
            <param name="len"></param>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.Contains(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.MergeByAndLogic(System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Using AND logic: 1 and 1 = 1; 1 and 0 = 0; 0 and 0 = 0
            </summary>
            <param name="arraysToMerge"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.MergeByOrLogic(System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Using OR logic: 1or1 = 1or0 = 1; 0or0 = 0
            </summary>
            <param name="arraysToMerge"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.MergeByXorLogic(System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Using XOR logic: 1xor1 = 0; 0xor0 = 0; 1xor0 = 1
            </summary>
            <param name="arraysToMerge"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.MergeByExcludeLogic(System.Byte[],System.Byte[])">
            <summary>
            Using EXCLUDE logic: 1notin1 = 0; 1notin0 = 1; 0notin0 = 0; 0notin1 = 0;
            </summary>
            <param name="array1"></param>
            <param name="array2"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.TextSearch.WABI.ExistsInDB">
            <summary>
            Technical if already in DB
            </summary>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.TextSearch_AND_logic(System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Returns last added documents first
            </summary>
            <param name="indexesToCheck"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.TextSearch_AND_logic(System.Collections.Generic.List{System.Byte[]},System.Int32,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="indexesToCheck"></param>
            <param name="docStart">when 0 not counted</param>
            <param name="docStop">when 0 not counted</param>
            <param name="descending"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.TextSearch.WABI.TextSearch_OR_logic(System.Collections.Generic.List{System.Byte[]},System.Int32)">
            <summary>
            
            </summary>
            <param name="indexesToCheck"></param>
            <param name="maximalReturnQuantity"></param>
            <returns></returns>
        </member>
    </members>
</doc>
