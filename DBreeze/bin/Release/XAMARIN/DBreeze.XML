<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DBreeze</name>
    </assembly>
    <members>
        <member name="T:DBreeze.DataTypes.Row`2">
            <summary>
            Row
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.Exists">
            <summary>
            Exists
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.Key">
            <summary>
            Key
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetTable(System.UInt32)">
            <summary>
            We are inside of the row.
            <para>This Method will give you ability to the nested tables which can be stored inside of table by tableIndex</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetValuePart(System.UInt32,System.UInt32)">
            <summary>
            Returns partial value representation starting from specif index and specified length.
            <para>To get full value as byte[] use GetValuePart(0)</para>
            </summary>
            <param name="startIndex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetValuePart(System.UInt32)">
            <summary>
            Returns partial value representation starting from specif index till and till the end of value.
            </summary>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.LinkToValue">
            <summary>
            Returns physical link to key/value if it exists, otherwise null,
            this link can be used by SelectDirect (always returns 8 bytes)
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetDataBlock(System.UInt32)">
            <summary>
            Returns datablock which identifier is stored in this row from specified index.
            <para></para>
            Insert dynamic lenght datablock is possible via tran.InsertDataBlock or NestedTable.InsertDataBlock.
            <para></para>
            can return null.
            </summary>
            <param name="dataBlockId"></param>
            <returns></returns>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.Value">
            <summary>
            Returns full value and converts it to the value data type.
            <para>To take full value or part of the value as byte[] use GetValuePart or GetBytes (for string types like DbAscii etc.)</para>
            <para>If your value contains serialized object inside or it's a string type (like DbAscii etc.), use Value.Get property.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.PrintOut(System.String)">
            <summary>
            Experimantal Console PrintOut
            </summary>
        </member>
        <member name="T:DBreeze.DataTypes.DbCustomSerializer`1">
            <summary>
            <para>Custom Serializer</para>
            <para></para>
            <para>To support JSON.NET, make a reference to their library and then somewhere before engine init add 2 lines:</para>
            <para>CustomSerializator.Serializator = JsonConvert.SerializeObject;</para>
            <para>CustomSerializator.Deserializator = JsonConvert.DeserializeObject;</para>
            <para></para>
            <para>Possible to make like this, without class instantiating:</para>
            <para>List&lt;string&gt; aa = new List&lt;string&gt;();</para>
            <para>aa.Add("test1")</para>
            <para>aa.Add("test2")</para>
            <para>-----inside of transaction---------</para>
            <para>tran.Insert&lt;uint, DbCustomSerializer&lt;List&lt;string&gt;&gt; &gt;("t1", i, aa);</para>
            <para>-----------------------------------</para>
            <para>foreach (var row in tran.SelectForward&lt;uint, DbCustomSerializer&lt;List&lt;string&gt;&gt; &gt;("t1"))</para>
            <para>Console.WriteLine("K: {0}; V: {1}", row.Key.ToString(), (row.Value == null) ? "NULL" : row.Value.Get.Count().ToString());</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DBreeze.DataTypes.DbCustomSerializer`1.SerializedObject">
            <summary>
            Returns serialized string representing the internal object
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbCustomSerializer`1.Get">
            <summary>
            Gets deserialized object
            </summary>
        </member>
        <member name="T:DBreeze.DataTypes.NestedTable">
            <summary>
            NestedTable
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.#ctor(DBreeze.DataTypes.NestedTableInternal,System.Boolean,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="nt"></param>
            <param name="insertTablesAllowed"></param>
            <param name="tableExists"></param>
        </member>
        <member name="P:DBreeze.DataTypes.NestedTable.ValuesLazyLoadingIsOn">
            <summary>
            When it's on iterators return Row with the key and a pointer to the value.
            <par>Value will be read out when we call it Row.Value.</par>
            <pa>When it's off we read value together with the key in one round</pa>
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.GetTable``1(``0,System.UInt32)">
            <summary>
            You are already in the table
            <para>This function will help to access another table by parent table key and its value index</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.CloseTable">
            <summary>
            Tries to close the table if no other threads are using it.
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertDataBlock(System.Byte[],System.Byte[])">
            <summary>
            Insert a dynamic size data block in the table storage, returns fixed 16 bytes length identifier
            <para></para>
            which can be stored in a table value from specified index.
            <para></para>
            Retrieve such DataBlock we can using Row.GetDataBlock.
            <para>The same statement is used to update datablock, received value must update row value who holds reference to it.</para>
            <para>Must be used as row column with dynamic length</para>
            </summary>
            <param name="initialPointer">if null creates new data block, if not null tries to overwrite existing data block</param>
            <param name="data"></param>
            <returns>returns created data block parameters of fixed 16 bytes length, which can be stored in the row value
            <para>and later reused for getting data block back</para>
            </returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDataBlock(System.Byte[])">
            <summary>
            Another way (second is via row by index where pointer is stored) to get stored data block
            </summary>
            <param name="initialPointer"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1,System.Byte[]@)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1,System.Byte[]@,System.Boolean@)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1,System.Byte[]@,System.Boolean@,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <param name="dontUpdateIfExists">When true - if value exists, we dont update it. If WasUpdated = true then value exists, if false - we have inserted new one</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Technical_SetTable_OverwriteIsNotAllowed">
            <summary>
            <para>After the end of transaction overwrite will be allowed again.</para>
            <para>Concerns overwriting of values, trie search nodes and dataBlocks.</para>
            <para>ref. documentation from [20130412]</para>
            </summary>
            <param name="isAllowed"></param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertDictionary``3(``0,System.Collections.Generic.Dictionary{``1,``2},System.UInt32,System.Boolean)">
            <summary>
            Inserts a dictionary into nested-table row.
            <para></para>
            Designed for simple dictionary data types.
            <para></para>
            Actually creates a new table inside of nested table row and handles it like dictionary.
            <para></para>
            If new Dictionary is supplied then non-existing keys in supplied DB will be removed from db
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get dictionary use SelectDictionary</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
            <returns>Returns Nested Table where insert was made</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertDictionary``2(System.Collections.Generic.Dictionary{``0,``1},System.Boolean)">
            <summary>
            Inserts dictionary into current nested table.
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
            <returns>current nested table</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDictionary``3(``0,System.UInt32)">
            <summary>
            Selects complete table from nested-table row nested table, by row nested-table index as Dictionary.
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDictionary``2">
            <summary>
            Selects completely current nested-table as a Dictionary.
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertHashSet``2(``0,System.Collections.Generic.HashSet{``1},System.UInt32,System.Boolean)">
            <summary>
            Inserts a HashSet (unique list of Keys) into nested-table row.
            <para></para>
            Actually creates a new table inside of nested table row and handles it like table with THashSetKey key any byte[] == null value.
            <para></para>
            If new HashSet is supplied then non-existing keys in supplied DB will be removed from db (withValuesRemove=true)
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get HashSet use SelectHashSet</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
            <returns>Returns Nested Table where insert was made</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertHashSet``1(System.Collections.Generic.HashSet{``0},System.Boolean)">
            <summary>
            Inserts HashSet into current nested-table
            </summary>
            <typeparam name="THashSetKey"></typeparam>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
            <returns>current nested table</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectHashSet``2(``0,System.UInt32)">
            <summary>
            Selects complete table from nested-table row nested table, by row nested-table index as HashSet (unique list of Keys).
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns>HashSet</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectHashSet``1">
            <summary>
            Returns completely current nested-table as a HashSet (unique list of Keys).
            </summary>
            <typeparam name="THashSetKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertPart``2(``0,``1,System.UInt32)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para> 
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertPart``2(``0,``1,System.UInt32,System.Byte[]@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para> 
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertPart``2(``0,``1,System.UInt32,System.Byte[]@,System.Boolean@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para> 
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Select``2(``0)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.DataTypes.NestedTable.readRootNode">
            <summary>
            TO be used in Select with ReadVisibilityScope as True. Is created only once per instantiated nested table. 
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Select``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, select will return key/value,</para>
            <para>like it was before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDirect``2(System.Byte[])">
            <summary>
            <para>EXPERIMENTAL</para>
            Returns Row by supplying direct pointer to key/value in the file.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="refToInsertedValue"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveAllKeys">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveKey``1(``0)">
            <summary>
            Removes a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveKey``1(``0,System.Boolean@)">
            <summary>
            Removes a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system</param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveKey``1(``0,System.Boolean@,System.Byte[]@)">
            <summary>
            Removes a key
            </summary>
            <typeparam name="TKey">type of the key</typeparam>
            <param name="key">key to delete</param>
            <param name="WasRemoved">indicates that key existed in the system</param>
            <param name="deletedValue">Will hold deleted value if WasRemoved is true</param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveKey``1(``0,System.Boolean@,System.Boolean,System.Byte[]@)">
            <summary>
            Removes a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system</param>
            <param name="retrieveDeletedValue">indicates if system should retrieve deleted value</param>
            <param name="deletedValue"></param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.ChangeKey``1(``0,``0)">
            <summary>
            Renames old key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="oldKey"></param>
            <param name="newKey"></param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.ChangeKey``1(``0,``0,System.Byte[]@)">
            <summary>
            Renames old key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.ChangeKey``1(``0,``0,System.Byte[]@,System.Boolean@)">
            <summary>
            Renames old key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
            <param name="WasChanged">indicates that oldKey existed and was succesfully changed</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Count">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Max``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Min``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForward``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForward``2(System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackward``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackward``2(System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartFrom``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartFrom``2(``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartFrom``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartFrom``2(``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardFromTo``2(``0,System.Boolean,``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardFromTo``2(``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardFromTo``2(``0,System.Boolean,``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardFromTo``2(``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWith``2(``0)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWith``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWithClosestToPrefix``2(``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWithClosestToPrefix``2(``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWithClosestToPrefix``2(``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWithClosestToPrefix``2(``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWith``2(``0)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWith``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkip``2(System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkip``2(System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkip``2(System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkip``2(System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkipFrom``2(``0,System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkipFrom``2(``0,System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkipFrom``2(``0,System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkipFrom``2(``0,System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.DataTypes.NestedTableInternal">
            <summary>
            In developing, will represent a table inside of the other table
            </summary>
        </member>
        <member name="F:DBreeze.DataTypes.NestedTableInternal.TableExists">
            <summary>
            Identifies that table is fake, because we always want to return data even default (count - 0, select - row with .Exists= false etc...)
            </summary>
        </member>
        <member name="T:DBreeze.DataTypes.DbAscii">
            <summary>
            String.Empty is will return NULL
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbAscii.Get">
            <summary>
            Returns string from the object
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.DataTypesConvertor.ConvertBack``1(System.Byte[])">
            <summary>
            CONVERTING FROM byte[] to the generic type
            </summary>
            <typeparam name="TData"></typeparam>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.DataTypes.DbXML`1">
            <summary>
            <para>Microsoft XML</para>
            <para></para>
            <para>Possible to make like this, without class instantiating:</para>
            <para>List&lt;string&gt; aa = new List&lt;string&gt;();</para>
            <para>aa.Add("test1")</para>
            <para>aa.Add("test2")</para>
            <para>-----inside of transaction---------</para>
            <para>tran.Insert&lt;uint, DbXML&lt;List&lt;string&gt;&gt;&gt;("t1", i, aa);</para>
            <para>-----------------------------------</para>
            <para>foreach (var row in tran.SelectForward&lt;uint, DbXML&lt;List&lt;string&gt;&gt;&gt;("t1"))</para>
            <para>Console.WriteLine("K: {0}; V: {1}", row.Key.ToString(), (row.Value == null) ? "NULL" : row.Value.Get.Count().ToString());</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DBreeze.DataTypes.DbXML`1.SerializedObject">
            <summary>
            Returns serialized string representing the internal object
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbXML`1.Get">
            <summary>
            Gets deserialized object
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbUnicode.Get">
            <summary>
            Returns string from the object
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbUTF8.Get">
            <summary>
            Returns string from the object
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeConfiguration.Backup">
            <summary>
            Incremental backup plan. If is not instantiated, incremental backup will be switch off
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeConfiguration.DBreezeDataFolderName">
            <summary>
            Folder where will reside DBreeze database files
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.eStorage.RemoteInstance">
            <summary>
            In case if database files are located on a remote host
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeConfiguration.Storage">
            <summary>
            DISK, MEMORY or Remote Instance. DEFAULT IS DISK,
            DBreezeDataFolderName must be supplied.
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.AlternativeTablesLocations">
            <summary>
            Pattern based way to specify storage and location for tables.
            <para>Key of this dictionary must contain table pattern e.g. Article$/Items# or Car456 or Items*</para>
            <para>Value, if is String.Empty, means that table will be located in memory.</para>
            <para>Value, if not empty, means physical storage folder path, where table should reside.</para>
            <para>If table doesn't intersect any pattern then default DB configuration will be overriden for the storage.</para>
            <para>If table intersects more the one pattern then first found will be applied.</para>
            <para>Help for patterns:</para>
            <para>$ * #</para>
            <para>"U" symbol in the following examples means intersection</para>
            <para>* - 1 or more of any symbol kind (every symbol after * will be cutted): Items* U Items123/Pictures</para>
            <para># - symbols (except slash) followed by slash and minimum another symbol: Items#/Picture U Items123/Picture</para>
            <para>$ - 1 or more symbols except slash (every symbol after $ will be cutted): Items$ U Items123;  Items$ !U Items123/Pictures </para>
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.RICommunicator">
            <summary>
            In case if we want to use storage layer RemoteInstance (RISR), this must be supplied.
            Answers for sending data to Remote Acceptor and returning answer back
            </summary>
        </member>
        <member name="T:DBreeze.DBreezeRemoteEngine">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeRemoteEngine.#ctor(DBreeze.DBreezeConfiguration)">
            <summary>
            DBreezeRemoteEngine instantiator
            </summary>
            <param name="dbreezeConfiguration"></param>
        </member>
        <member name="M:DBreeze.DBreezeRemoteEngine.Init">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeRemoteEngine.GetTransaction">
            <summary>
            Returns transaction object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DBreezeRemoteEngine.GetTransaction(DBreeze.eTransactionTablesLockTypes,System.String[])">
            <summary>
            Returns transaction object.
            </summary>
            <param name="tablesLockType">
            <para>SHARED: threads can use listed tables in parallel. Must be used together with tran.SynchronizeTables command, if necessary.</para>
            <para>EXCLUSIVE: if other threads use listed tables for reading or writing, current thread will be in a waiting queue.</para>
            </param>
            <param name="tables"></param>
            <returns>Returns transaction object</returns>
        </member>
        <member name="P:DBreeze.DBreezeRemoteEngine.Scheme">
            <summary>
            Returns DBreeze schema object
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTableStorage.RestoreTableFromTheOtherTable(System.String)">
            <summary>
            Works only for master tables
            </summary>
            <param name="newTableFullPath"></param>
        </member>
        <member name="T:DBreeze.LianaTrie.NestedTablesCoordinator">
            <summary>
            Represents a bound to the LTrie nested tables coordinator.
            1. Gets ability to remember Inserted Tables to perform cascade commit.
            2. Rebind internal root-start if 2 or more horizontal tables are inserted into 1 value during one transaction (value expand case)
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.NestedTablesCoordinator._nestedTables">
            <summary>
            Key is a pointer to the full value, then in the value new Dictionary
            where key is root_start
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.NestedTablesCoordinator.ModificationThreadId">
            <summary>
            Will be taken into consideration only from MasterTrie.
            Set up to -1 after Commit and Rollback, Set To Thread id when tran.InsertTable is called
            using this flag we will be able to regulate returns (based on useCache or not for nested Tables)
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.AddNestedTable(System.Byte[]@,System.UInt64,System.Int64,DBreeze.DataTypes.NestedTableInternal)">
            <summary>
            LTrie makes in case of InsertTable call
            </summary>
            <param name="nestedTable"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.TransactionalCommitFinished">
            <summary>
            Committing nested tables
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.Commit">
            <summary>
            Committing nested tables
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.TransactionalCommit">
            <summary>
            Transactional Commit Nested
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.TransactionalRollback">
            <summary>
            Transactional Rollback nested
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.GetTable(System.Byte[]@,System.Int64)">
            <summary>
            Returns null if table is not in the coordinator, otherwise returns reference to the table
            </summary>
            <param name="fullValueStart"></param>
            <param name="rootStart"></param>
            <returns></returns>      
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.Remove(System.Byte[]@)">
            <summary>
            Cascade remove all of all nested and sub-nested tables under the key
            </summary>
            <param name="key"></param>
        </member>
        <member name="F:DBreeze.LianaTrie.Iterations.Backward.ReturnKeyValuePair">
            <summary>
            If we use load Key already With Value, or just key and link to the value
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.Iterations.Backward.ItBwdFromTo(DBreeze.LianaTrie.LTrieGenerationNode,System.Byte[],System.Boolean)">
            <summary>
            ItBwdFromTo
            </summary>
            <param name="gn"></param>
            <param name="generationMapLine"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.Iterations.Backward.IterateBackwardFromTo(System.Byte[],System.Byte[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            IterateBackwardFromTo
            </summary>
            <param name="initKey"></param>
            <param name="stopKey"></param>
            <param name="inclStartKey"></param>
            <param name="inclStopKey"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.Iterations.Forward.ReturnKeyValuePair">
            <summary>
            If we use load Key already With Value, or just key and link to the value
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.Iterations.Forward.ItFrwFromTo(DBreeze.LianaTrie.LTrieGenerationNode,System.Byte[],System.Boolean)">
            <summary>
            ItFrwFromTo
            </summary>
            <param name="gn"></param>
            <param name="generationMapLine"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.Iterations.Forward.IterateForwardFromTo(System.Byte[],System.Byte[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            IterateForwardFromTo
            </summary>
            <param name="initKey"></param>
            <param name="stopKey"></param>
            <param name="inclStartKey"></param>
            <param name="inclStopKey"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationMap.GenerateMapNodesValuesUpToIndex(System.Int32)">
            <summary>
            Used for finding out hash from Generation Map
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.QuantityReservationSlots">
            <summary>
            Reservations are calculated by Schema. They Depend upon quantity of Existing Kids.
            QuantityAvailableReservations is calculated in ReadSelf if Kid.Pointer equals to ZeroPointer - it means reservation.
            Default is 0
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.ToChangeParentNode">
            <summary>
            When New Node is created it's true
            After Reading Node it must become false,
            After WriteSelf it will be or true or false.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.KidsBeforeModification">
            <summary>
            Field which contains either null (if Generation node is empty and had no kids) or value in format of prepared for Save Kids,
            in case if ReadOutExistingNode.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.MaximumKidLineLength">
            <summary>
            Is calculated as LengthOfTheKidsBlockInFile(2 bytes) + (256 * (DefaultPointerLen + 1[byte definition]))
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.SetupKidWithValue(System.Byte,System.Boolean,System.Byte[]@,System.Byte[]@,System.Boolean,System.Boolean@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="kid"></param>
            <param name="lastElementOfTheKey"></param>
            <param name="fullKey"></param>
            <param name="value"></param>
            <param name="useExistingPointerToValue"></param>
            <param name="WasUpdated">true means that value existed and was updated</param>
            <param name="dontUpdateIfExists">When true - if value exists, we dont update it. If WasUpdated = true then we value exists, if false - we have inserted new one</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.RemoveKid(System.Byte,System.Boolean,System.Byte[]@,System.Boolean@,System.Boolean,System.Byte[]@)">
            <summary>
            Pointer to the removing key value can be null, if such key never existed
            </summary>
            <param name="kid"></param>
            <param name="lastElementOfTheKey"></param>
            <param name="key"></param>
            <param name="ptrToValue"></param>
            <param name="WasRemoved">indicates that value existed if true</param>
            <param name="retrieveDeletedValue">indicates if we must also return deleted value</param>
            <param name="WasRemoved">deleted value as byte[] will be here</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.TryOverWriteValuePartially(System.Byte[],System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@)">
            <summary>
            Returns pointer to the newly stored value
            </summary>
            <param name="ptr"></param>
            <param name="value"></param>
            <param name="fullKey"></param>
            <param name="startIndex">from which point we should overwrite value</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.TryOverWriteValue(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Returns pointer to the newly stored value
            </summary>
            <param name="ptr"></param>
            <param name="value"></param>
            <param name="fullKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.GetQuantityOfReservationSlots">
            <summary>
            Calculating Quantity of Reservations slots for 0 and 1 Evolutions.
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.LianaTrie.LTrie">
            <summary>
            Liana Trie
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.Cache">
            <summary>
            Cache for overwriting nodes and values
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.TableIsModified">
            <summary>
            Identifies that after Saving0generationNode was made no changes (Add,Remove etc)
            Used via TableIsModified
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie._DtTableFixed">
            <summary>
            Is by Commit and Rollback only, we will use it to return correct ReadRootNodes out to the system
            Access via DtTableFixed interface ITrie
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.NestedTablesCoordinator">
            <summary>
            Coordinator of nested tables
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.OverWriteIsAllowed">
            <summary>
            Concerns Nodes, Values, DataBlocks.
            Flag can be setup only via nested table or transaction
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.ValuesLazyLoadingIsOn">
            <summary>
            When it's on iterators, Select and SelectDirect return Row with the key and a pointer to the value.
            <par>Value will be read out when we call it Row.Value.</par>
            <pa>When it's off we read value together with the key in one round</pa>
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.#ctor(DBreeze.Storage.IStorage)">
            <summary>
            Liana Trie
            </summary>
            <param name="storage"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.CheckTableIsOperable">
            <summary>
            Will return exception, if not.
            Must be called by all functions
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.RollBack">
            <summary>
            RollBack
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetTable(DBreeze.LianaTrie.LTrieRow,System.Byte[]@,System.UInt32,DBreeze.LianaTrie.LTrie,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="row"></param>
            <param name="tableIndex"></param>
            <param name="masterTrie"></param>
            <param name="insertTable">Regulates if InsertTable or SelectTable was called (ability to create table if it doesn't exist)</param>
            <param name="useCache">Regulates READ table thread or WRITE table thread - visibilityscope</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Add(System.Byte[],System.Byte[])">
            <summary>
            Adds key. Overload without refs
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Add(System.Byte[]@,System.Byte[]@,System.Boolean@,System.Boolean)">
            <summary>
            Adds key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <param name="dontUpdateIfExists">When true - if value exists, we dont update it. If WasUpdated = true then we value exists, if false - we have inserted new one</param>
            <returns>returns physical link to value</returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.AddPartially(System.Byte[],System.Byte[],System.UInt32,System.Int64@)">
            <summary>
            Overload without refs
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.AddPartially(System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@)">
            <summary>
            REMEMBER THAT 
            all keys are first formed in memory and then copied to the disk, so it's not for storing movies inside of the value.
            For storing movies (BLOBs) will be used other approach, see docu.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.AddPartially(System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@,System.Boolean@)">
            <summary>
            REMEMBER THAT 
            all keys are first formed in memory and then copied to the disk, so it's not for storing movies inside of the value.
            For storing movies (BLOBs) will be used other approach, see docu.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="WasUpdated"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Remove(System.Byte[]@,System.Boolean@,System.Boolean,System.Byte[]@)">
            <summary>
            Removes the key
            </summary>
            <param name="key"></param>
            <param name="WasRemoved">indicates that value existed if true</param>
            <param name="retrieveDeletedValue">indicates if we should bind deleted value to the result</param>
            <param name="deletedValue">interesting only if WasRemoved = true and retrieveDeletedValue is true</param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.SaveGenerationMap">
            <summary>
            Technical function.
            Used by Fetch SYNCHRO_READ FUNCs, which use write root node, to make last in-memory changes to flash on the disk, before commit.
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetTrieReadNode(System.Int64@)">
            <summary>
            Interface function which recreates every time new rootNode from itself by every new function call.
            and also packs root node last fixation dateTime (ROLL or COMMIT).
            It will be used for READ FUNC's via Transaction, they can decide if to create new instance of read root or use existing.
            Returns NULL is !TableIsOperable.
            </summary>
            <param name="modifiedDt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Count(System.Boolean)">
            <summary>
            if useCache = true; uses newly created root node, else uses writing root node
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Count(DBreeze.Tries.ITrieRootNode)">
            <summary>
            Can be used inside of DBreeze - concerns all read functions
            </summary>
            <param name="SYNCHRO_READ"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetKey(System.Byte[],System.Boolean)">
            <summary>
            if useCache = true; uses newly created root node, else uses writing root node
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetKey(System.Byte[]@,DBreeze.Tries.ITrieRootNode)">
            <summary>
            DBreeze compatible.
            Extension, which helps to READ-THREADS smartly utilize created before read-roots
            </summary>
            <param name="key"></param>
            <param name="readRootNode">if null then WRITE-ROOT NODE</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateForwardStartsWith(System.Byte[])">
            <summary>
            Always creates new root to get committed data
            </summary>
            <param name="startKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateForwardStartsWithClosestToPrefix(System.Byte[])">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateForwardStartsWithClosestToPrefix(System.Byte[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateForwardStartsWithClosestToPrefix(System.Byte[],DBreeze.Tries.ITrieRootNode)">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <param name="readRootNode"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateBackwardStartsWithClosestToPrefix(System.Byte[])">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateBackwardStartsWithClosestToPrefix(System.Byte[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateBackwardStartsWithClosestToPrefix(System.Byte[],DBreeze.Tries.ITrieRootNode)">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <param name="readRootNode"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.SingleCommit">
            <summary>
            Wrapper for ITransactable
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.SingleRollback">
            <summary>
            Wrapper for ITransactable
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie._modificationThreadId">
            <summary>
            This variable becomes value more then -1 via TrasactionCoordinator, when it returns TableForWrite
            It becomes -1 after Transaction End call.
            No need of lock.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.Val">
            <summary>
            0-255, in case if ValueKid = false, 256 if ValueKid = true;
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.Ptr">
            <summary>
            Pointer to the next node or to the value
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.Exists">
            <summary>
            Default value is false
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.LinkToNode">
            <summary>
            Works when ValueKid = false.
            True is link to node
            False if link to value.
            Default is true.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.ValueKid">
            <summary>
            Identifies that it's a value for this node, not the kid from 0-255.
            If true, Ptr has link to the value.
            Default is false
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKidsInNode.ValueIsEmpty">
            <summary>
            Indicates that Kids Line contains no Value-Kid
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKidsInNode.AllowSave">
            <summary>
            Optimizer. We don't want to overwrite node, if really nothing has changed. In the beginning value is true.
            ParseKids function make it false.
            Later by Adding or removing elements we either make it true or leave as false.
            search in the code  (!AllowSave).
            The flag work result is visible in GetKidsForSave function.
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieKidsInNode.ParseKids(System.Byte[]@)">
            <summary>
            Returns quantity of reservation slots
            </summary>
            <param name="bKids"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieKidsInNode.GetKidValue">
            <summary>
            Gets Value kid (before 0-255)
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieKidsInNode.GetKidsForSave(System.Int32)">
            <summary>
            Returns null, if not necessary to save generation node (cause it didn't change).  AllowSave = false;
            </summary>
            <param name="reservation"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRootNode.RecordsCount">
            <summary>
            Indicates quantity of Records in the table
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.DeserializeRootNode">
            <summary>
            bytes[] to objects
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.SerializeRootNode">
            <summary>
            Root to byte[]
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.AddKey(System.Byte[]@,System.Byte[]@,System.Boolean@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="WasUpdated">true means that value existed and was updated</param>
            <param name="dontUpdateIfExists">When true - if value exists, we dont update it. If WasUpdated = true then we value exists, if false - we have inserted new one</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.AddKeyPartially(System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@,System.Boolean@)">
            <summary>
            Returns link to the full value together with the key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.RemoveAll(System.Boolean)">
            <summary>
            Check TransactionCommit in case of RemoveAll with file Recreation.
            Note if some other threads are reading parallel data, exception will be thrown in their transaction.
            It's correct.
            </summary>
            <param name="withFileRecreation"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.ChangeKey(System.Byte[]@,System.Byte[]@)">
            <summary>
            Takes value fresh no committed value row.GetFullValue(false);
            </summary>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.ChangeKey(System.Byte[]@,System.Byte[]@,System.Byte[]@)">
            <summary>
            Takes value fresh no committed value row.GetFullValue(false);
            </summary>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="refToInsertedValue">returns ptr in the file to the new key</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.RemoveKey(System.Byte[]@,System.Boolean@,System.Boolean,System.Byte[]@)">
            <summary>
            Will return pointer to the value of the removing kid (if it existed). Otherwise NULL.
            </summary>
            <param name="key"></param>
            <param name="WasRemoved">indicates that value existed if true</param>
            <param name="retrieveDeletedValue">indicates if we should bind deleted value to the result</param>
            <param name="deletedValue">interesting only if WasRemoved = true and retrieveDeletedValue is true</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.GetKey(System.Byte[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieSetupKidResult.ValueLink">
            <summary>
            Link to the full value line (together with the key)
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRow.ValueStartPointer">
            <summary>
            Represents pointer to the value in physical file, remember for READ must come via sync-cache
            -1 if not defined
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRow.ValueFullLength">
            <summary>
            If ValueStartPointer == -1, has no meaning
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRow.Key">
            <summary>
            Default is null
            </summary>
        </member>
        <member name="P:DBreeze.LianaTrie.LTrieRow.LinkToValue">
            <summary>
            Experimental, instead of Value, we supply link to the value
            </summary>
        </member>
        <member name="P:DBreeze.LianaTrie.LTrieRow.Exists">
            <summary>
            Default is false
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRow.GetPartialValue(System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Returns either value partially or null
            </summary>
            <param name="startIndex"></param>
            <param name="length"></param>
            <param name="useCache">if true, then only committed data will be shown</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRow.GetFullValue(System.Boolean)">
            <summary>
            Returns either value as byte array or null if value doesn't exist
            </summary>
            <param name="useCache">if true, then only committed data will be shown</param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieWriteCache.rootTransaction">
            <summary>
            Represents old Root as byte[] array for the moment while we make Transactional Commit. Otherwise remains null
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.RootNodeWrite(System.Byte[])">
            <summary>
            
            </summary>
            <param name="rootData"></param>
            <param name="oldRootData"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.RootNodeRead">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.Commit(System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="rootData"></param>
            <param name="oldRootData"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.RollBack">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.TransactionalCommit(System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="rootData"></param>
            <param name="oldRootData"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.TransactionalCommitFinished">
            <summary>
            We need here to clear old root and call Storage Commit is finished
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.TransactionalRollBack">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.RecreateDB">
            <summary>
            Used by Root Node RemoveAll with key re-creation
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GetNodeKids(System.Byte[])">
            <summary>
            Returns NULL if not found
            </summary>
            <param name="generationMapLine"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.AddMapKids(System.Byte[],System.Byte[])">
            <summary>
            If line exists - makes nothing, otherwise writes in
            </summary>
            <param name="generationMapLine"></param>
            <param name="kidsBeforeModification"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GenerationNodeWritingEnd(System.Byte[],System.Byte[])">
            <summary>
            Writing Generation Node to the end of File.
            We use current generation node pointer to black list it.
            if we reuse this new pointer inside of one transaction for overwriting, we don't need to back it up for rollback any more.
            </summary>
            <param name="pointer"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GenerationNodeWritingOver(System.Byte[],System.Byte[])">
            <summary>
            OverWriting Generation Node, we supply params where, oldData and newData.
            Old Data - not used thou
            </summary>
            <param name="pointer"></param>
            <param name="oldData"></param>
            <param name="newData"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GenerationNodeRead(System.Boolean,System.Byte[],System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache"></param>
            <param name="pointer"></param>
            <param name="cachedGenerationMapLine"></param>
            <param name="MaximumNodeLineLength"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadDynamicDataBlock(System.Byte[]@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="initPtr"></param>
            <param name="useCache"></param>
            <returns>return NULL if not found or stored value is NULL, otherwise returns byte[]</returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.WriteDynamicDataBlock(System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="initPtr"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ValueWritingEnd(System.Byte[]@,System.Byte[])">
            <summary>
             
            </summary>
            <param name="data"></param>
            <param name="oldPtr"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ValueWritingOver(System.Byte[],System.Byte[]@,System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="pointer"></param>
            <param name="oldData"></param>
            <param name="newData"></param>
            <param name="key"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadKeyValue(System.Boolean,System.Byte[],System.Int64@,System.UInt32@,System.Byte[]@,System.Byte[]@)">
            <summary>
            Interanl Function for reading Key and Value in one set. Initial block read is setUp to 4096 bytes
            </summary>
            <param name="useCache"></param>
            <param name="pointer">ptr to KVP</param>
            <param name="valueStartPtr">will be more then 0 only in case if valueLength more then 0. It makes no diff for the null and byte[0] values in this context. Avoid byte[0]</param>
            <param name="valueLength">will be 0 if val is null and if val is byte[0]</param>
            <param name="key"></param>
            <param name="val"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadKey(System.Boolean,System.Byte[])">
            <summary>
            Internal function for reading key only from DB storage
            Is called from ReadKey
            </summary>
            <param name="useCache"></param>
            <param name="pointer">ptr to KVP</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadValue(System.Byte[],System.Boolean,System.Int64@,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="pointer">ptr to KVP</param>
            <param name="useCache"></param>
            <param name="valueStartPtr"></param>
            <param name="valueLength"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadValuePartially(System.Byte[],System.UInt32,System.UInt32,System.Boolean,System.Int64@,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="pointer"></param>
            <param name="startIndex"></param>
            <param name="length"></param>
            <param name="useCache"></param>
            <param name="valueStartPtr">returns pointer where value starts from. -1 if can't be determined</param>
            <param name="valueLength">returns full value length; 0 - default</param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.SchemeInternal.CachedTableNames">
            <summary>
            serves, cache of physical file names and corresponding virtual user table names
            </summary>
        </member>
        <member name="M:DBreeze.SchemeInternal.CachedTableNames.Add(System.String,System.UInt64)">
            <summary>
            
            </summary>
            <param name="userTableName"></param>
            <param name="fileName"></param>
        </member>
        <member name="M:DBreeze.SchemeInternal.CachedTableNames.Remove(System.String)">
            <summary>
            
            </summary>
            <param name="userTableName"></param>
        </member>
        <member name="M:DBreeze.SchemeInternal.CachedTableNames.GetFileName(System.String)">
            <summary>
            Returns 0, if can't find
            </summary>
            <param name="userTableName"></param>
        </member>
        <member name="F:DBreeze.SchemeInternal.OpenTable.qOpen">
            <summary>
            Quantity of open exemplars
            </summary>
        </member>
        <member name="M:DBreeze.SchemeInternal.OpenTable.Add">
            <summary>
            Inceases quantity of usage by one
            </summary>
        </member>
        <member name="M:DBreeze.SchemeInternal.OpenTable.Remove(System.UInt64)">
            <summary>
            Decreases quantity of usage by one and returns true if table can be automatically closed
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.UserTableNameIsOk(System.String)">
            <summary>
            Checks validity of the user table name
            </summary>
            <param name="tableName"></param>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.UserTablePatternIsOk(System.String)">
            <summary>
            Throws exception if smth. happened.
            Returns either original table name or cutted if * is found
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.PatternsIntersect(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.TableNamesIntersect(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Checks intersection between two lists of patterns
            </summary>
            <param name="list1"></param>
            <param name="list2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.TableNamesContains(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Checks intersection between List of patterns and one pattern
            </summary>
            <param name="list1"></param>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.TestIntersectionPatterns(System.Boolean,System.String,System.String)">
            <summary>
            TEST Intersections pattern
            </summary>
            <param name="assumption">your assumption, if intersects or not</param>
            <param name="p1">pattern 1</param>
            <param name="p2">pattern 2</param>
        </member>
        <member name="F:DBreeze.Scheme.AutoCloseOpenTables">
            <summary>
            Flag that closes file of the table if threads don't use it for reading or writing.
            </summary>
        </member>
        <member name="M:DBreeze.Scheme.GetPhysicalPathToTheUserTable(System.String)">
            <summary>
            ONLY FOR INTERNAL NEEDS, lock must be handeled by outer procedure.
            Users must use GetTablePathFromTableName.
            Transactions Journal after start will try to delete RollbackFiles of the finished transactions.
            For this it needs to know exact pathes.
            For now all tables stored in one folder. Later we will have extra config file which lets to reside 
            some of tables in the other folders. 
            This function is an access globalizer to physical file locations by userTableName.
            !!!!TRAnJRNL, WHEN RESTORES ROLLBACK, MUST REFER TO Scheme trie settings in the future, FOR NOW DEFAULT
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetTablePathFromTableName(System.String)">
            <summary>
            Returns physical path to the table file, if table doesn't exists in the Scheme returns String.Empty
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetUserTableNameAsByte(System.String)">
            <summary>
            Adds static prefix to all user table names, to
            make selection of tables for different purposes easier with StartsWith function
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetTable(System.String)">
            <summary>
            Returns table for READ, WRITE FUNC
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.CheckAlternativeTableLocationsIntersections(System.String,System.String@)">
            <summary>
            Checks if in configuration was supplied alternative path for table location.
            Returns true if intersection was found.
            Alternative Path equals to String.Empty - locate in Memory
            </summary>
            <param name="userTableName"></param>
            <param name="alternativePath"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.CloseTables(System.Collections.Generic.Dictionary{System.String,System.Nullable{System.UInt64}})">
            <summary>
            Called by Transaction, when it's time to be Disposed and close tables.
            Tables will be closed only in case of other threads don't use it.
            </summary>
            <param name="closeOpenTables"></param>
        </member>
        <member name="M:DBreeze.Scheme.DeleteAllReleatedTableFiles(System.String)">
            <summary>
            Used by GetTableFor Write, if table is newly created and we have such file name
            </summary>
            <param name="fullTableFilePath"></param>
        </member>
        <member name="M:DBreeze.Scheme.IfUserTableExists(System.String)">
            <summary>
            Returns if user table exists
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetUserTableNamesStartingWith(System.String)">
            <summary>
            Returns List of user tables starting from specified mask.
            If mask is String.Empty returns all user tables
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.DeleteTable(System.String)">
            <summary>
            Deletes user table
            </summary>
            <param name="userTableName"></param>
        </member>
        <member name="M:DBreeze.Scheme.RenameTable(System.String,System.String)">
            <summary>
            Renames user table, if it existed.
            <para>Safe, will make operation only when other threads stop to work with the oldTable</para>
            </summary>
            <param name="oldUserTableName"></param>
            <param name="newUserTableName"></param>
        </member>
        <member name="M:DBreeze.Scheme.RenameTableInternal(System.String,System.String)">
            <summary>
            Renames user table, if it existed.
            <para>If there are threads which are working with this table, rename will not be finished and will return false</para>
            </summary>
            <param name="oldUserTableName"></param>
            <param name="newUserTableName"></param>
            <returns>true if successfully renamed, otherwise false</returns>
        </member>
        <member name="T:DBreeze.Exceptions.DBreezeException">
            <summary>
            Unified class for Debreeze exceptions
            </summary>
        </member>
        <member name="M:DBreeze.Exceptions.DBreezeException.GenerateException(DBreeze.Exceptions.DBreezeException.eDBreezeExceptions,System.String,System.Exception)">
            <summary>
            Internal
            </summary>
            <param name="exceptionType"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Exceptions.TableNotOperableException">
            <summary>
            This is a specific Exception which will bring to DB is not opearable state, we need to analyze this type of exception separately,
            that's why extra class.
            </summary>
        </member>
        <member name="F:DBreeze.Diagnostic.SpeedStatistic.ToConsole">
            <summary>
            Default is Debug.WriteLine, can be changed to Console.WriteLine
            </summary>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.StartCounter(System.String)">
            <summary>
            Starts counter
            </summary>
            <param name="counterName"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.StopCounter(System.String)">
            <summary>
            Stops counter
            </summary>
            <param name="counterName"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.GetCounter(System.String)">
            <summary>
            Returns Counter object.
            Can return NULL if counter not found
            </summary>
            <param name="counterName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut">
            <summary>
            Prints out stat for all counters without clearing statistic 
            </summary>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut(System.String)">
            <summary>
            Prints out counter without clearing statistic for this counter
            </summary>
            <param name="counterName"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut(System.String,System.Boolean)">
            <summary>
            Prints out specified counter.
            </summary>
            <param name="counterName"></param>
            <param name="withClearingCounter"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut(System.Boolean)">
            <summary>
            Prints out stats for all counters
            </summary>
            <param name="withResetingStatistic">resets statistic</param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.OpenRemoteTable(System.String)">
            <summary>
            Always first command, which send table name and receives back RemoteTableId
            Opens remote table (data, rollback and rollback helper files), if it doesn't exists, then creates it.
            All other operations are based on this RemoteTableId.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.CloseRemoteTable">
            <summary>
            CloseRemoteTable, returns nothing
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DeleteRemoteTable">
            <summary>
            DeleteRemoteTable
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DataFileWrite(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Writes to remote data file, return sets DataFileLength
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="withFlush"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileWrite(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Writes to remote rollback file, return sets RollbackFileLength
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="withFlush"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackHelperFileWrite(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Writes to remote rollback helper file, return sets RollbackFileHelperLength
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="withFlush"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DataFileRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads Datafile
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            RollbackFileRead
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackHelperFileRead(System.Byte[],System.Int32,System.Int32)">
            <summary>
            RollbackHelperFileRead
            </summary>
            <param name="array"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.DataFileFlush">
            <summary>
            Data file Flush
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileFlush">
            <summary>
            Rollback file flush
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteInstanceCommander.RollbackFileRecreate">
            <summary>
            RollbackFileRecreate
            </summary>
        </member>
        <member name="T:DBreeze.Storage.RemoteInstance.RemoteTable">
            <summary>
            Represents one table, is managed by RemoteTablesHandler, server data, rollback and rollback helper files.
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.#ctor(System.String,System.UInt64)">
            <summary>
            
            </summary>
            <param name="_fileName"></param>
            <param name="tableId"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.OpenRemoteTable">
            <summary>
            OpenRemoteTable
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.CloseRemoteTable">
            <summary>
            CloseRemoteTable
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.DeleteRemoteTable">
            <summary>
            DeleteRemoteTable
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.DataFileWrite(System.Int64,System.Boolean,System.Byte[])">
            <summary>
            DataFileWrite
            </summary>
            <param name="position"></param>
            <param name="withFlush"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackFileWrite(System.Int64,System.Boolean,System.Byte[])">
            <summary>
            RollbackFileWrite
            </summary>
            <param name="position"></param>
            <param name="withFlush"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackHelperFileWrite(System.Int64,System.Boolean,System.Byte[])">
            <summary>
            RollbackFileWrite
            </summary>
            <param name="position"></param>
            <param name="withFlush"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.DataFileRead(System.Int64,System.Int32)">
            <summary>
            DataFileRead
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackFileRead(System.Int64,System.Int32)">
            <summary>
            RollbackFileRead
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackHelperFileRead(System.Int64,System.Int32)">
            <summary>
            RollbackHelperFileRead
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.DataFileFlush">
            <summary>
            DataFileFlush
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackFileFlush">
            <summary>
            RollbackFileFlush
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTable.RollbackFileRecreate">
            <summary>
            RollbackFileRecreate
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Storage.RemoteInstance.RemoteTablesHandler">
            <summary>
            ServerSide. Servs one local database.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RemoteInstance.RemoteTablesHandler._tIds">
            <summary>
            fileName to id binding
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTablesHandler.#ctor(System.String)">
            <summary>
            RemoteTablesHandler
            </summary>
            <param name="databasePreFolderPath"></param>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTablesHandler.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RemoteInstance.RemoteTablesHandler.ParseProtocol(System.Byte[])">
            <summary>
            ParseProtocol
            </summary>
            <param name="protocol"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Storage.RISR">
            <summary>
            DBreeze Remote Instance SR implementation
            Specially designed for DBreeze specific storage format.
            Not for common usage.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR.IsOperable">
            <summary>
            Indicates subsystem vitality
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR._randBuf">
            <summary>
            Random buffer
            </summary>
        </member>
        <member name="T:DBreeze.Storage.RISR.r">
            <summary>
            Record in rollback is characterized with 
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.r.o">
            <summary>
            offset in rollback file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.r.l">
            <summary>
            Lenght in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR._rollbackCache">
            <summary>
            Rollback cache
            Key is offset in data file, value is corresponding offset and lenght in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR.maxRandomBufferSize">
            <summary>
            Random buffer maximal size before flush
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR.MaxRollbackFileSize">
            <summary>
            Rollback file re-creation after initialization
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR.eofData">
            <summary>
            Pointer to the end of file, before current commit
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR._storageFixTime">
            <summary>
            DateTime when file was initialized. Is remembered by LTrieRow, based on this file.
            If file is change after RestoreTableFromTheOtherTable or RecreateFiles,
            LTrieRow will have different version and will return exception.
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.Length">
            <summary>
            Physical length of the storage file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.StorageFixTime">
            <summary>
            Returns time of file initiation, ead remarks on 
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.TrieSettings">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.DbreezeConfiguration">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Storage.RISR.Table_FileName">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.RestoreInitRollback">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.ParseRollBackFile(System.Byte[])">
            <summary>
            
            </summary>
            <param name="rbd"></param>
        </member>
        <member name="M:DBreeze.Storage.RISR.RestoreTableFromTheOtherTable(System.String)">
            <summary>
            
            </summary>
            <param name="newTableFullPath"></param>
        </member>
        <member name="M:DBreeze.Storage.RISR.RecreateFiles">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.FlushSequentialBuffer">
            <summary>
            Must be called from lock_fs
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_WriteToTheEnd(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_WriteByOffset(System.Byte[],System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_WriteByOffset(System.Int64,System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.RISR.FlushRandomBuffer">
            <summary>
            Is called only from lock_fs and must be finished by calling NET_Flush
            </summary>     
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_Read(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RISR.Table_Read(System.Boolean,System.Int64,System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.RISR.Commit">
            <summary>
            Cleans all buffers and flushes data to the disk
            </summary>
        </member>
        <member name="F:DBreeze.Storage.RISR.TransactionalCommitIsStarted">
            <summary>
            Transactional Commit is started
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.TransactionalCommit">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.TransactionalCommitIsFinished">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.TransactionalRollback">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RISR.Rollback">
            <summary>
            Standard and transactional rollback
            </summary>
        </member>
        <member name="M:DBreeze.Storage.Backup.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="backupFolderName">Folder where will be restored incremental backup</param>
        </member>
        <member name="P:DBreeze.Storage.Backup.IncrementalBackupFileIntervalMin">
            <summary>
            Identifies how often will be created new file for backup (Minimum 5 minutes).
            Default value is one day
            </summary>
        </member>
        <member name="P:DBreeze.Storage.Backup.BackupFolderName">
            <summary>
            Folder where backup files will be created
            </summary>
        </member>
        <member name="M:DBreeze.Storage.Backup.BackupFileNamesParser.ParseFilename(System.String)">
            <summary>
            Helper for table file names transitions for backup
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.Backup.WriteBackupElement(System.UInt64,System.Byte,System.Int64,System.Byte[])">
            <summary>
            Represents incremental backup of protocol 1
            </summary>
            <param name="fileNumber"></param>
            <param name="type">0 - table file, 1 - rollback file, 2 - rollbackhelper, 3 - recreate table file, 5 - removing complete table </param>
            <param name="pos"></param>
            <param name="data"></param>
        </member>
        <member name="T:DBreeze.Storage.BackupRestorer">
            <summary>
            Access to Database restoration from incremental backups.
            </summary>
        </member>
        <member name="T:DBreeze.Storage.BackupRestorer.BackupRestorationProcess">
            <summary>
            Object characterizes the backup restoration process
            </summary>
        </member>
        <member name="P:DBreeze.Storage.BackupRestorer.BackupRestorationProcess.ReadinessInProcent">
            <summary>
            How many procesnt of restoration is done
            </summary>
        </member>
        <member name="P:DBreeze.Storage.BackupRestorer.BackupRestorationProcess.Finished">
            <summary>
            true when restore is completed
            </summary>
        </member>
        <member name="E:DBreeze.Storage.BackupRestorer.OnRestore">
            <summary>
            Subscribe on it to receive notification about restore process
            </summary>
        </member>
        <member name="P:DBreeze.Storage.BackupRestorer.DataBaseFolder">
            <summary>
            Place where resides or should reside database
            </summary>
        </member>
        <member name="P:DBreeze.Storage.BackupRestorer.BackupFolder">
            <summary>
            Place where reside incremnetal dbreeze backup files
            </summary>
        </member>
        <member name="F:DBreeze.Storage.BackupRestorer.ds">
            <summary>
            Holder of filenames and file handlers
            </summary>
        </member>
        <member name="M:DBreeze.Storage.BackupRestorer.StartRestoration">
            <summary>
            Starts backup restore routine
            </summary>
        </member>
        <member name="T:DBreeze.Storage.MSR">
            <summary>
            DBreeze random and sequential disk IO buffers implementation.
            Specially designed for DBreeze specific storage format.
            Not for common usage.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR.IsOperable">
            <summary>
            Indicates subsystem vitality
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR._randBuf">
            <summary>
            Random buffer
            </summary>
        </member>
        <member name="T:DBreeze.Storage.MSR.r">
            <summary>
            Record in rollback is characterized with 
            </summary>
        </member>
        <member name="P:DBreeze.Storage.MSR.r.o">
            <summary>
            offset in rollback file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.MSR.r.l">
            <summary>
            Lenght in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR._rollbackCache">
            <summary>
            Rollback cache
            Key is offset in data file, value is corresponding offset and lenght in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR.maxRandomBufferSize">
            <summary>
            Random buffer maximal size before flush
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR.MaxRollbackFileSize">
            <summary>
            Rollback file re-creation after initialization
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR.eofData">
            <summary>
            Pointer to the end of file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR._storageFixTime">
            <summary>
            DateTime when file was initialized. Is remembered by LTrieRow, based on this file.
            If file is change after RestoreTableFromTheOtherTable or RecreateFiles,
            LTrieRow will have different version and will return exception.
            </summary>
        </member>
        <member name="P:DBreeze.Storage.MSR.Length">
            <summary>
            Physical length of the storage file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.MSR.StorageFixTime">
            <summary>
            Returns time of file initiation, ead remarks on 
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.RecreateFiles">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_WriteToTheEnd(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_WriteByOffset(System.Byte[],System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_WriteByOffset(System.Int64,System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.MSR.FlushRandomBuffer">
            <summary>
            Is called only from lock_fs and must be finished by calling NET_Flush
            </summary>
            <param name="commit"></param>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_Read(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache">if actual overwritten data must be used</param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MSR.Table_Read(System.Boolean,System.Int64,System.Int32)">
            <summary>
            
            </summary>
            <param name="readActual">if actual overwritten data must be used</param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MSR.Commit">
            <summary>
            Cleans all buffers and flushes data to the disk
            </summary>
        </member>
        <member name="F:DBreeze.Storage.MSR.TransactionalCommitIsStarted">
            <summary>
            Transactional Commit is started
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.TransactionalCommit">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.TransactionalCommitIsFinished">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.TransactionalRollback">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MSR.Rollback">
            <summary>
            Standard and transactional rollback
            </summary>
        </member>
        <member name="T:DBreeze.Storage.FSR">
            <summary>
            DBreeze random and sequential disk IO buffers implementation.
            Specially designed for DBreeze specific storage format.
            Not for common usage.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR.IsOperable">
            <summary>
            Indicates subsystem vitality
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR._randBuf">
            <summary>
            Random buffer
            </summary>
        </member>
        <member name="T:DBreeze.Storage.FSR.r">
            <summary>
            Record in rollback is characterized with 
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.r.o">
            <summary>
            offset in rollback file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.r.l">
            <summary>
            Lenght in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR._rollbackCache">
            <summary>
            Rollback cache
            Key is offset in data file, value is corresponding offset and lenght in rollback file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR.maxRandomBufferSize">
            <summary>
            Random buffer maximal size before flush
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR.MaxRollbackFileSize">
            <summary>
            Rollback file re-creation after initialization
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR.eofData">
            <summary>
            Pointer to the end of file, before current commit
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR._storageFixTime">
            <summary>
            DateTime when file was initialized. Is remembered by LTrieRow, based on this file.
            If file is change after RestoreTableFromTheOtherTable or RecreateFiles,
            LTrieRow will have different version and will return exception.
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.Length">
            <summary>
            Physical length of the storage file
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.StorageFixTime">
            <summary>
            Returns time of file initiation, ead remarks on 
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.TrieSettings">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.DbreezeConfiguration">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Storage.FSR.Table_FileName">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.RestoreInitRollback">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.ParseRollBackFile(System.Byte[])">
            <summary>
            
            </summary>
            <param name="rbd"></param>
        </member>
        <member name="M:DBreeze.Storage.FSR.RestoreTableFromTheOtherTable(System.String)">
            <summary>
            
            </summary>
            <param name="newTableFullPath"></param>
        </member>
        <member name="M:DBreeze.Storage.FSR.RecreateFiles">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.FlushSequentialBuffer">
            <summary>
            Must be called from lock_fs
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_WriteToTheEnd(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_WriteByOffset(System.Byte[],System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_WriteByOffset(System.Int64,System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.FSR.FlushRandomBuffer">
            <summary>
            Is called only from lock_fs and must be finished by calling NET_Flush
            </summary>     
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_Read(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.FSR.Table_Read(System.Boolean,System.Int64,System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.FSR.Commit">
            <summary>
            Cleans all buffers and flushes data to the disk
            </summary>
        </member>
        <member name="F:DBreeze.Storage.FSR.TransactionalCommitIsStarted">
            <summary>
            Transactional Commit is started
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.TransactionalCommit">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.TransactionalCommitIsFinished">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.TransactionalRollback">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.FSR.Rollback">
            <summary>
            Standard and transactional rollback
            </summary>
        </member>
        <member name="M:DBreeze.Storage.IStorage.Table_Read(System.Boolean,System.Int64,System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache">true=reading threads, false = writing threads</param>
            <param name="offset"></param>
            <param name="quantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.IStorage.Table_Read(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            
            </summary>
            <param name="useCache">true=reading threads, false = writing threads</param>
            <param name="offset"></param>
            <param name="quantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.IStorage.RestoreTableFromTheOtherTable(System.String)">
            <summary>
            
            </summary>
            <param name="newTableFullPath"></param>
        </member>
        <member name="P:DBreeze.Storage.IStorage.StorageFixTime">
            <summary>
            UTC DateTime when table was initialized
            </summary>
        </member>
        <member name="P:DBreeze.Storage.IStorage.Length">
            <summary>
            Length of the Storage
            </summary>
        </member>
        <member name="T:DBreeze.Storage.MemoryStorage.eMemoryExpandStartegy">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.#ctor(System.Int32,System.Int32,DBreeze.Storage.MemoryStorage.eMemoryExpandStartegy)">
            <summary>
            
            </summary>
            <param name="initialCapacity">Initial Memory Capacity in bytes</param>
            <param name="increaseOnBytes">Rules is strategy is FIXED_LENGTH_INCREASE, quantity of bytes to increse memory</param>
            <param name="strategy">Memory expand strategy</param>
        </member>
        <member name="P:DBreeze.Storage.MemoryStorage.RawBuffer">
            <summary>
            Gives an ability to access field itself. Must use external logical lock.
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Clear(System.Boolean)">
            <summary>
            Sets EOF pointer to 0.
            <para>USE withInternalArrayResize by necessity. If it's true then array will be re-initialized to initial capacity</para>
            <para>this also will call GC and the whole process will take some time.</para>
            <para>If false, only pointer EOF will be set to 0, capacity of the array will not be changed - very fast</para>
            </summary>
            <param name="withInternalArrayResize"></param>
        </member>
        <member name="P:DBreeze.Storage.MemoryStorage.EOF">
            <summary>
            End of file
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.GetFullData">
            <summary>
            Can return null
            </summary>
            <returns></returns>
        </member>
        <member name="P:DBreeze.Storage.MemoryStorage.MemorySize">
            <summary>
            Total reserved field length. EOF shows the end of useful information.
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Read(System.Int32,System.Int32)">
            <summary>
            If lenght = 0 returns new byte[0]
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write(System.Byte[]@,System.Int32)">
            <summary>
            Must be called from lock
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write_ToTheEnd(System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write_ToTheEnd(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write_ByOffset(System.Int32,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write_ByOffset(System.Int32,System.Byte[])">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Writes_ByOffsets(System.Collections.Generic.Dictionary{System.Int64,System.Byte[]})">
            <summary>
            
            </summary>
            <param name="datas"></param>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.POINTER_LENGHT">
            <summary>
            User parameter for the table.
            <para>Quantity of bytes which represent pointer inside of raw file (5 bytes = 1 Terrabyte, so the trie with 5 bytes pointer len can't be longer then 1 terrabyte).</para>
            <para>If you plan to have your table more then 1TB, set this value to bigger value, before table creation</para>
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.ROOT_SIZE">
            <summary>
            For internal needs
            Quantity of bytes which reside ROOT_NODE
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.ROOT_START">
            <summary>
            For internal needs.
            Offset where root should reside in the file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.InternalTable">
            <summary>
            If table is for internal purposes (like Scheme or Transaction Journal)
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.AlternativeTableStorageFolder">
            <summary>
            Next 3 concern alternative table storage pathes.
            </summary>
        </member>
        <member name="M:DBreeze.TransactionTablesLocker.AddSession(DBreeze.eTransactionTablesLockTypes,System.String[])">
            <summary>
            
            </summary>
            <param name="lockType"></param>
            <param name="tables"></param>
            <returns>false if thread grants access, false if thread is in a queue</returns>
        </member>
        <member name="M:DBreeze.TransactionTablesLocker.RemoveSession">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.TransactionTablesLocker.Dispose">
            <summary>
            MUST BE CALLED BY ENGINE DISPOSE (After all other DBreeze disposes)
            </summary>
        </member>
        <member name="T:DBreeze.Tries.ITrieRootNode">
            <summary>
            Identifies any type of RootNode in different tries
            </summary>
        </member>
        <member name="T:DBreeze.DBreezeEngine">
            <summary>
            Main DBreeze Database class.
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeEngine.MainFolder">
            <summary>
            DBreeze version number
            </summary>        
        </member>
        <member name="F:DBreeze.DBreezeEngine.DBisOperableReason">
            <summary>
            must be filled with a text note who brought to DBisOperable = false
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeEngine.RemoteEngine">
            <summary>
            Initialized from DBreezeRemoteEngine
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeEngine.Configuration">
            <summary>
            Dbreeze Configuration.
            For now BackupPlan is included.
            Later can be added special settings for each entity defined by string pattern.
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeEngine.#ctor">
            <summary>
            For DbreezeRemoteEngine wrapper
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeEngine.#ctor(DBreeze.DBreezeConfiguration)">
            <summary>
            Dbreeze instantiator
            </summary>
            <param name="dbreezeConfiguration"></param>
        </member>
        <member name="M:DBreeze.DBreezeEngine.ConstructFromConfiguration(DBreeze.DBreezeConfiguration)">
            <summary>
            Constructing Dbreeze from dbreezeConfiguration
            </summary>
            <param name="dbreezeConfiguration"></param>
        </member>
        <member name="M:DBreeze.DBreezeEngine.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="DBreezeDataFolderName"></param>
        </member>
        <member name="M:DBreeze.DBreezeEngine.InitDb">
            <summary>
            InitDb
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeEngine.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeEngine.GetTransaction">
            <summary>
            Returns transaction object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DBreezeEngine.GetTransaction(DBreeze.eTransactionTablesLockTypes,System.String[])">
            <summary>
            Returns transaction object.
            </summary>
            <param name="tablesLockType">
            <para>SHARED: threads can use listed tables in parallel. Must be used together with tran.SynchronizeTables command, if necessary.</para>
            <para>EXCLUSIVE: if other threads use listed tables for reading or writing, current thread will be in a waiting queue.</para>
            </param>
            <param name="tables"></param>
            <returns>Returns transaction object</returns>
        </member>
        <member name="P:DBreeze.DBreezeEngine.Scheme">
            <summary>
            Returns DBreeze schema object
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.ITransactable.ITRCommitFinished">
            <summary>
            Is called by Transaction Journal, to make root available for all and delete rollback file
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.ITransactable.TransactionIsFinished(System.Int32)">
            <summary>
            Transaction Coordinator notifies table that transaction is finished
            and table can clear ModificationThreadId and run RollBackProcedure (if transaction was finised without Commit)
            </summary>
            <param name="transactionThreadId"></param>
        </member>
        <member name="M:DBreeze.Transactions.ITransactable.ModificationThreadId(System.Int32)">
            <summary>
            TransactionsCoordinator via this function will explain to the table that transactionThreadId thread will make modificatons.
            later when calling fetch functions, table will be able to return different RootNodes depending upon the thread
            </summary>
            <param name="transactionThreadId"></param>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.ManagedThreadId">
            <summary>
            Managed threadId of the transaction
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction._transactionType">
            <summary>
            0 - standard transaction, 1 - locked transaction (Shared Exclusive)
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.Transaction.ValuesLazyLoadingIsOn">
            <summary>
            When it's on iterators return Row with the key and a pointer to the value.
            <par>Value will be read out when we call it Row.Value.</par>
            <pa>When it's off we read value together with the key in one round</pa>
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SynchronizeTables(System.Collections.Generic.IList{System.String})">
            <summary>
            Use before any table modification command inside of the transaction.
            <para>In case if transaction is going to modify only 1 table, reservation is not necessary, there is no danger of the deadlock.</para>
            <para></para>
            <para>Table Names available patterns:</para>
            <para>$ * #</para>
            <para>* - 1 or more of any symbol kind (every symbol after * will be cutted): Items* U Items123/Pictures</para>
            <para># - symbols (except slash) followed by slash and minimum another symbol: Items#/Picture U Items123/Picture</para>
            <para>$ - 1 or more symbols except slash (every symbol after $ will be cutted): Items$ U Items123;  Items$ !U Items123/Pictures </para>
            </summary>
            <param name="tablesNamesPatterns">can be either tableName or pattern like Articles#/Items*</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SynchronizeTables(System.String[])">
            <summary>
             Use before any table modification command inside of transaction
            <para>In case if transaction is going to modify only 1 table, reservation is not necessary, there is no danger of the deadlock.</para>
            <para></para>
            <para>Table Names available patterns:</para>
            <para>$ * #</para>
            <para>* - 1 or more of any symbol kind (every symbol after * will be cutted): Items* U Items123/Pictures</para>
            <para># - symbols (except slash) followed by slash and minimum another symbol: Items#/Picture U Items123/Picture</para>
            <para>$ - 1 or more symbols except slash (every symbol after $ will be cutted): Items$ U Items123;  Items$ !U Items123/Pictures </para>
            </summary>
            <param name="tablesNamesPatterns"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.AddOpenTable(System.String)">
            <summary>
            This must be called only if we use not cached opening
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.transactionWriteTables">
            <summary>
            Small buffer for the tables where we are going to write in.
            It will boost performance in case of Bulk inserts or updates
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.GetWriteTableFromBuffer(System.String)">
            <summary>
            Automatically tries to take Write Table from buffer or from system, throws exception if smth. happens
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.transactionReadTables">
            <summary>
            Small buffer for the tables, we are going to read from.
            </summary>
        </member>
        <member name="T:DBreeze.Transactions.Transaction.Rtbe">
            <summary>
            Technical class, who holds reference to the table and its last modification dts
            ReadTableElement
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.GetReadTableFromBuffer(System.String,DBreeze.Tries.ITrieRootNode@)">
            <summary>
            IS USED BY NON-RANGE SELECTS OPERATORS
            Retuns LTrie (or later by necessity ITrie) and as out variable ReadRootNode which must be used for READ FUNC data acquiring.
            READ FUNCs calling this proc will receive table and as out var. root, this root will be supplied to the trie.
            If root is null, then write root will be used.
            If table is null - table doesn't exist.
            </summary>
            <param name="tableName"></param>
            <param name="root"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.GetReadTableFromBuffer(System.String,DBreeze.Tries.ITrieRootNode@,System.Boolean)">
            <summary>
            Retuns LTrie (or later by necessity ITrie) and as out variable ReadRootNode which must be used for READ FUNC data acquiring.
            READ FUNCs calling this proc will receive table and as out var. root, this root will be supplied to the trie.
            If root is null, then write root will be used.
            If table is null - table doesn't exist.
            </summary>
            <param name="tableName"></param>
            <param name="root"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Commit">
            <summary>
            Commits all changes made inside of the current transaction.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Rollback">
            <summary>
            Rollsback all changes made by current transaction before last Commit.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveKey``1(System.String,``0)">
            <summary>
            Removes specified key, if it existed
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveKey``1(System.String,``0,System.Boolean@)">
            <summary>
            Removes specified key, if it exists.
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system, before removing</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveKey``1(System.String,``0,System.Boolean@,System.Byte[]@)">
            <summary>
            Removes specified key, if it exists. Return value which was deleted if WasRemoved is true.
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system, before removing</param>
            <param name="deletedValue">Will hold deleted value if WasRemoved is true</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveKey``1(System.String,``0,System.Boolean@,System.Boolean,System.Byte[]@)">
            <summary>
            Internal function.
            Removes specified key, if it exists. Can return value which was deleted if WasRemoved is true
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system, before removing</param>
            <param name="retrieveDeletedValue">indicates if system should retrieve deleted value</param>
            <param name="deletedValue"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveAllKeys(System.String,System.Boolean)">
            <summary>
            Removes all records in the table
            </summary>
            <param name="tableName"></param>
            <param name="withFileRecreation">also recreates table file, if true</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ChangeKey``1(System.String,``0,``0)">
            <summary>
            Renames key old its value on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="oldKey"></param>
            <param name="newKey"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ChangeKey``1(System.String,``0,``0,System.Byte[]@)">
            <summary>
            Renames key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ChangeKey``1(System.String,``0,``0,System.Byte[]@,System.Boolean@)">
            <summary>
            Renames key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
            <param name="WasChanged">indicates that oldKey existed and was succesfully changed</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertDataBlock(System.String,System.Byte[],System.Byte[])">
            <summary>
            Insert a dynamic size data block in the table storage, returns fixed 16 bytes length identifier
            <para></para>
            which can be stored in a table value from specified index.
            <para></para>
            Retrieve such DataBlock we can using Row.GetDataBlock.
            <para>The same statement is used to update datablock, received value must update row value who holds reference to it.</para>
            <para>Must be used as row column with dynamic length</para>
            </summary>
            <param name="tableName"></param>
            <param name="initialPointer">if null creates new data block, if not null tries to overwrite existing data block</param>
            <param name="data"></param>
            <returns>returns created data block parameters of fixed 16 bytes length, which can be stored in the row value
            <para>and later reused for getting data block back</para>
            </returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDataBlock(System.String,System.Byte[])">
            <summary>
            Another way (second is via row by index where pointer is stored) to get stored data block
            </summary>
            <param name="tableName"></param>
            <param name="ptrToDataBlock">16 byte pointer identifier, received after insertDataBlock</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1,System.Byte[]@)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1,System.Byte[]@,System.Boolean@)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1,System.Byte[]@,System.Boolean@,System.Boolean)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <param name="dontUpdateIfExists">When true - if value exists, we dont update it. If WasUpdated = true then value exists, if false - we have inserted new one</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Technical_SetTable_OverwriteIsNotAllowed(System.String)">
            <summary>
            <para>After the end of transaction overwrite will be allowed again.</para>
            <para>Concerns overwriting of values, trie search nodes and dataBlocks.</para>
            <para>ref. documentation from [20130412]</para>
            </summary>
            <param name="tableName"></param>      
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertPart``2(System.String,``0,``1,System.UInt32)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertPart``2(System.String,``0,``1,System.UInt32,System.Byte[]@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param> 
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertPart``2(System.String,``0,``1,System.UInt32,System.Byte[]@,System.Boolean@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para>
            <para>Second generic parameter represents datatype of the inserting parameter in the middle of the value</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param> 
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param> 
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertTable``1(System.String,``0,System.UInt32)">
            <summary>
            Will create internal table if it doesn't exist and return it.
            </summary>
            <param name="tableName"></param>
            <param name="tableNumber"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectTable``1(System.String,``0,System.UInt32)">
            <summary>
            If internal table doesn't exist will not create it but must always return 
            NestedTable, which will be internally marked as absent. 
            In this case all Add/Remove operations will have to throw exception and
            Select operations will return their default values
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertDictionary``3(System.String,``0,System.Collections.Generic.Dictionary{``1,``2},System.UInt32,System.Boolean)">
            <summary>
            Inserts a dictionary into master-table row.
            <para></para>
            Actually creates a new table inside of master table row and handles it like table with TDictionaryKey key any TDictionaryValue value.
            <para></para>
            If new Dictionary is supplied then non-existing keys in supplied DB will be removed from db
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get dictionary use SelectDictionary</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertDictionary``2(System.String,System.Collections.Generic.Dictionary{``0,``1},System.Boolean)">
            <summary>
            Inserts a dictionary into master-table
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDictionary``3(System.String,``0,System.UInt32)">
            <summary>
            Selects complete table from master-table row nested table, by row nested-table index as Dictionary.
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDictionary``2(System.String)">
            <summary>
            Selects complete master-table as Dictionary
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertHashSet``2(System.String,``0,System.Collections.Generic.HashSet{``1},System.UInt32,System.Boolean)">
            <summary>
            Inserts a HashSet (unique list of Keys) into master-table row.
            <para></para>
            Actually creates a new table inside of master table row and handles it like table with THashSetKey key any byte[] == null value.
            <para></para>
            If new HashSet is supplied then non-existing keys in supplied DB will be removed from db (withValuesRemove=true)
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get HashSet use SelectHashSet</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertHashSet``1(System.String,System.Collections.Generic.HashSet{``0},System.Boolean)">
            <summary>
            Inserts a HashSet (unique list of Keys) into master-table itself
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectHashSet``2(System.String,``0,System.UInt32)">
            <summary>
            Selects complete table from master-table row nested table, by row nested-table index as HashSet (unique list of Keys).
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectHashSet``1(System.String)">
            <summary>
            Selects complete master-table as a HashSet into memory
            </summary>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Count(System.String)">
            <summary>
            Returns records quantity inside of the the table
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Max``2(System.String)">
            <summary>
            Returns row with the maximal key.
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Min``2(System.String)">
            <summary>
            Returns row with the minimal key.
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Select``2(System.String,``0)">
            <summary>
            Selects specified key from the table
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Select``2(System.String,``0,System.Boolean)">
            <summary>
            Selects specified key from the table
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, select will return key/value,</para>
            <para>like it was before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDirect``2(System.String,System.Byte[])">
            <summary>
            Returns Row by supplying direct pointer to key/value in the file.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="refToInsertedValue"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForward``2(System.String)">
            <summary>
            Iterates table forward (ordered by key ascending).
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForward``2(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackward``2(System.String)">
            <summary>
            Iterates table backward (ordered by key descending).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackward``2(System.String,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartFrom``2(System.String,``0,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="includeStartFromKey">if start key will be included in the final result</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartFrom``2(System.String,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="includeStartFromKey">if start key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartFrom``2(System.String,``0,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="includeStartFromKey">if start key will be included in the final result</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartFrom``2(System.String,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="includeStartFromKey">if start key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified StartKey up to specified StopKey
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified StartKey up to specified StopKey
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified StartKey down to specified StopKey.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified StartKey down to specified StopKey.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartsWith``2(System.String,``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting and including specified key part (big-endian from byte[] point of view)</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithKeyPart"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartsWith``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting and including specified key part (big-endian from byte[] point of view)</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartsWithClosestToPrefix``2(System.String,``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithClosestPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartsWithClosestToPrefix``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartsWithClosestToPrefix``2(System.String,``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithClosestPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartsWithClosestToPrefix``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartsWith``2(System.String,``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting and including specified key part (big-endian from byte[] point of view)</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithKeyPart"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartsWith``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting and including specified key part (big-endian from byte[] point of view)</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardSkip``2(System.String,System.UInt64)">
            <summary>
            Iterates table forward (ordered by key ascending), skipping from the first key specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardSkip``2(System.String,System.UInt64,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending), skipping from the first key specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardSkip``2(System.String,System.UInt64)">
            <summary>
            Iterates table backward (ordered by key descending), skipping from the last key back specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardSkip``2(System.String,System.UInt64,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending), skipping from the last key back specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardSkipFrom``2(System.String,``0,System.UInt64)">
            <summary>
            Iterates table forward (ordered by key ascending), skipping from specified key specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardSkipFrom``2(System.String,``0,System.UInt64,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending), skipping from specified key specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardSkipFrom``2(System.String,``0,System.UInt64)">
            <summary>
            Iterates table backward (ordered by key descending), skipping from specified key back specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardSkipFrom``2(System.String,``0,System.UInt64,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending), skipping from specified key back specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="skippingQuantity">if start key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RestoreTableFromTheOtherFile(System.String,System.String)">
            <summary>
            Experimental. Replaces existing table with the other table, created out of this engine.
            Reading threads will wait till this operation occurs.
            Note that prototype table will be deleted.
            </summary>
            <param name="tableName"></param>
            <param name="newTableFullPath"></param>
        </member>
        <member name="F:DBreeze.Transactions.TransactionsCoordinator._transactions">
            <summary>
            Dictionary of all active transactions. Key is ManagedThreadId
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionsCoordinator.GetSchema">
            <summary>
            Fast access to the Schema object.
            Used by Transaction class
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTransaction(System.Int32,DBreeze.eTransactionTablesLockTypes,System.String[])">
            <summary>
            
            </summary>
            <param name="transactionType">0 = standard transaction, 1 - locked transaction</param>
            <param name="lockType"></param>
            <param name="tables"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTransactionUnit(System.Int32)">
            <summary>
            
            </summary>
            <param name="transactionThreadId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.UnregisterTransaction(System.Int32)">
            <summary>
            
            </summary>
            <param name="transactionThreadId"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.UnregisterAllTransactions">
            <summary>
            Is called by the engine on Dispose.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.RegisterWriteTablesForTransaction(System.Int32,System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            Access synchronizer.
            All calls of the WRITE LOCATOR come over this function.
            </summary>
            <param name="transactionThreadId"></param>
            <param name="tablesNames"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTable_WRITE(System.String,System.Int32)">
            <summary>
            Can return NULL (if DbIsNotOperatable)
            </summary>
            <param name="tableName"></param>
            <param name="transactionThreadId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTable_READ(System.String,System.Int32)">
            <summary>
            Can return NULL if table doesn't exist
            Can return NULL (if DbIsNotOperatable)
            
            Differs from GetTable_Write:
            1. table is not registered for Write;
            2. Table is not created, if doesn't exist.
            </summary>
            <param name="tableName"></param>
            <param name="transactionThreadId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.StopEngine">
            <summary>
            Normal Engine Stop, usually in case of Main Thread or DLL disposing
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionsJournal.MaxlengthOfTransactionFile">
            <summary>
            We try to clear tranasction file, when its length is more then 10MB and if it's possible
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionsJournal._transactionsTables">
            <summary>
            Key: transaction number, counting up from the engine start
            Value: Dictionary containing as a Key usertableName, as value link to the table
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsJournal.AddTableForTransaction(System.UInt64,DBreeze.Transactions.ITransactable)">
            <summary>
            Every table inside of the transaction before calling Transaction Commit, goes to this in-memory dictionary
            </summary>
            <param name="tranNumber"></param>
            <param name="table"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsJournal.RemoveTransactionFromDictionary(System.UInt64)">
            <summary>
            Used in case of failed transaction of multiple tables, to clean in-memory dictionary
            </summary>
            <param name="tranNumber"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsJournal.GetTransactionNumber">
            <summary>
            Returns new transaction number
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Transactions.TransactionUnit">
            <summary>
            This object includes class Transaction (visible for the user) and holds internally technical transaction information.
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._transaction">
            <summary>
            Represents object which will be used by user, there we have all query methods, depending upon query we now if the table has to be locked or not.
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.TransactionsCoordinator">
            <summary>
            Easy access to transactin coordinator for the Transaction which is visible for the user
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.Transaction">
            <summary>
            Transaction visible for the user
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.TransactionThreadId">
            <summary>
            
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._sync_transactionWriteTables">
            <summary>
            Lock for all tables definitions inside current transaction
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._transactionWriteTables">
            <summary>
            It holds all tables marked for possible mutations
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._transactionWriteTablesAwaitingReservation">
            <summary>
            List of tables which are waiting for reservation for writing, we need it to predict deadlock situations.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.AddTransactionWriteTablesAwaitingReservation(System.Collections.Generic.List{System.String})">
            <summary>
            Used by TransactionCoordinator.RegisterWriteTablesForTransaction
            </summary>
            <param name="tablesNames"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.AddTransactionWriteTable(System.String,DBreeze.Transactions.ITransactable)">
            <summary>
            Adds a table which will take place in transaction operations.
            Reserved has value null, Real (which are acquired by Transaction for Write) has ITransactable filled.
            ITransactable = null, gives to differ from toched and reserved.
            </summary>
            <param name="tableName"></param>
            <param name="table">if null - will be added to Reservation table</param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.GetTransactionWriteTables">
            <summary>
            Doesn't need pattern check
            Returns all tables which took place in write operation for the current transaction
            Without reserved as Text tables only which have real ITransactable inside
            </summary>
            <returns></returns>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.TransactionWriteTablesCount">
            <summary>
            returns count of reserved tables, used by transaction just to find out if reservation (or first table modification) was done or not.
            reservation can be done only once.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.If_TableIsReservedForWrite(System.String)">
            <summary>
            Used inside of Transaction, we can choose fot READ or READ_SYNCHRO for READ FUNCs
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.GetTransactionWriteTablesNames">
            <summary>
            Returns only table names for reservation
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.Commit">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.RollBack">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Utils.Async.AsyncOperations.DoAsync``1(System.Action{``0},``0,System.Action)">
            <summary>
            Executes async, then calls Callback function
            </summary>
            <typeparam name="TInput"></typeparam>
            <param name="f"></param>
            <param name="arg"></param>
            <param name="callback"></param>
        </member>
        <member name="T:DBreeze.Utils.BloomFilter.Filter`1.HashFunction">
            <summary>
            A function that can be used to hash input.
            </summary>
            <param name="input">The values to be hashed.</param>
            <returns>The resulting hash code.</returns>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32)">
            <summary>
            Creates a new Bloom filter, specifying an error rate of 1/capacity, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            A secondary hash function will be provided for you if your type T is either string or int. Otherwise an exception will be thrown. If you are not using these types please use the overload that supports custom hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Bloom filter, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            A secondary hash function will be provided for you if your type T is either string or int. Otherwise an exception will be thrown. If you are not using these types please use the overload that supports custom hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,DBreeze.Utils.BloomFilter.Filter{`0}.HashFunction)">
            <summary>
            Creates a new Bloom filter, specifying an error rate of 1/capacity, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, and T is string or int a hash function will be provided for you.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,System.Single,DBreeze.Utils.BloomFilter.Filter{`0}.HashFunction)">
            <summary>
            Creates a new Bloom filter, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, and T is string or int a hash function will be provided for you.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,System.Single,DBreeze.Utils.BloomFilter.Filter{`0}.HashFunction,System.Int32,System.Int32)">
            <summary>
            Creates a new Bloom filter.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, and T is string or int a hash function will be provided for you.</param>
            <param name="m">The number of elements in the BitArray.</param>
            <param name="k">The number of hash functions to use.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.Add(`0)">
            <summary>
            Adds a new item to the filter. It cannot be removed.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.Contains(`0)">
            <summary>
            Checks for the existance of the item in the filter for a given probability.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:DBreeze.Utils.BloomFilter.Filter`1.Truthiness">
            <summary>
            The ratio of false to true bits in the filter. E.g., 1 true bit in a 10 bit filter means a truthiness of 0.1.
            </summary>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.computeHash(System.Int32,System.Int32,System.Int32)">
            <summary>
            Performs Dillinger and Manolios double hashing. 
            </summary>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.hashInt32(`0)">
            <summary>
            Hashes a 32-bit signed int using Thomas Wang's method v3.1 (http://www.concentric.net/~Ttwang/tech/inthash.htm).
            Runtime is suggested to be 11 cycles. 
            </summary>
            <param name="input">The integer to hash.</param>
            <returns>The hashed result.</returns>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.hashString(`0)">
            <summary>
            Hashes a string using Bob Jenkin's "One At A Time" method from Dr. Dobbs (http://burtleburtle.net/bob/hash/doobs.html).
            Runtime is suggested to be 9x+9, where x = input.Length. 
            </summary>
            <param name="input">The string to hash.</param>
            <returns>The hashed result.</returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.EnlargeByteArray_BigEndian(System.Byte[],System.Int32)">
            <summary>
            Enlarges byte array till given size filling with 0 from start the rest of the length.
            Ex: byte[] a = new byte[] {1,2,3}; a.EnlargeByteArray_BigEndian(6) = new byte[] {0,0,0,1,2,3};
            If array for enlargement equals null new byte[size] will be returned, if array for enlargement length more or equal size then the same array will be returned.
            </summary>
            <param name="ar"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.EnlargeByteArray_LittleEndian(System.Byte[],System.Int32)">
            <summary>
            Enlarges byte array till given size filling with 0 after values of the supplied array.
            Ex: byte[] a = new byte[] {1,2,3}; a.EnlargeByteArray_LittleEndian(6) = new byte[] {1,2,3,0,0,0};
            If array for enlargement equals null new byte[size] will be returned, if array for enlargement length more or equal size then the same array will be returned.
            </summary>
            <param name="ar"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Substring(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Substring int-dimensional byte arrays
            </summary>
            <param name="ar"></param>
            <param name="startIndex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Substring(System.Byte[],System.Int32)">
            <summary>
            Substring int-dimensional byte arrays from and till the end
            </summary>
            <param name="ar"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CloneArray(System.Byte[])">
            <summary>
            Works only for int-dimesional arrays only
            </summary>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CopyInside(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies one array (source) into another (destination extension).
            <para>Destination array is taken as this</para>
            </summary>
            <param name="destArray"></param>
            <param name="destOffset"></param>
            <param name="srcArray"></param>
            <param name="srcOffset"></param>
            <param name="quantity"></param>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CopyInside(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Copies fully one array (source) into another (destination extension). Extra parameter destination offset.
            <para>Doesn't return anything, but changes destination array by reference.</para>
            <para>Can Throw exception if destArray.Length less then (destOffset + srcArray.Length)</para>
            <para>, for this use CopyInsideArrayCanGrow</para>
            </summary>
            <param name="destArray"></param>
            <param name="destOffset"></param>
            <param name="srcArray"></param>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CopyInsideArrayCanGrow(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Will return finally created array 
            <para>byte[] b = new byte[] { 1, 2, 3 };</para>
            <para>byte[] v = b.CopyInsideArrayCanGrow(1, new byte[] { 5, 6, 7 });</para>
            <para>will return v = byte[] { 1, 5, 6, 7 }</para>
            </summary>
            <param name="destArray"></param>
            <param name="destOffset"></param>
            <param name="srcArray"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.RemoveLeadingElement(System.Byte[],System.Byte)">
            <summary>
            Removes leading element from the array.
            Never returns null, but can return new byte[] {} (Length=0)
            </summary>
            <param name="array"></param>
            <param name="elementToRemove"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Reverse(System.Byte[])">
            <summary>
            Array.Reverse is the same fast, but reverses by reference the parameter-array, what is not acceptable
            </summary>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Concat(System.Byte[],System.Byte[])">
            <summary>
            Fastest Method. Works only for int-dimesional arrays only. 
            When necessary to concat many arrays use ConcatMany
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Concat(System.Byte,System.Byte)">
            <summary>
            FOR OPTIMITATION LIKE Concat(this byte[] ar1, byte ar2)
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Concat(System.Byte,System.Byte[])">
            <summary>
            FOR OPTIMITATION LIKE Concat(this byte[] ar1, byte ar2)
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ConcatMany(System.Byte[],System.Byte[][])">
            <summary>
            Fast when necessary to concat many arrays
            Example: byte[] s = new byte[] { 1, 2, 3 }; s.ConcatMany(new byte[] { 2, 3, 4 }, new byte[] { 3, 7, 8 }, new byte[] { 9, 10, 11 });
            Also: ((byte[])null).ConcatMany(new byte[] { 2, 3, 4 }, new byte[] { 3, 7, 8 }, new byte[] { 9, 10, 11 });
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.indexOfStringInByteArray(System.Byte[],System.String,System.Text.Encoding)">
            <summary>
            If not found returns -1
            </summary>
            <param name="ar"></param>
            <param name="search"></param>
            <param name="en"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IndexOfByteArray(System.Byte[],System.Byte[])">
            <summary>
            Searches Start index of the byte[] pattern inside of the byte array
            If not found returns -1
            </summary>
            <param name="ar"></param>
            <param name="search"></param>
            <param name="en"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Byte(System.Byte[])">
            <summary>
            From 1 byte array returns byte
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Byte_NULL(System.Byte[])">
            <summary>
            From 2 bytes array returns byte?
            If array length is not equal to 2 bytes returns null
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_DateTime(System.Byte[])">
            <summary>
            8-byte array tries to convert to DateTime
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_DateTime_zCompatibility(System.Byte[])">
            <summary>
            DON't use it (only for compatibility reasons described in docu from [20120922])
            BigEndian 8 bytes tries to convert to Ticks
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_DateTime_NULL(System.Byte[])">
            <summary>
            Returns DateTime? from 9-byte array
            If array is not equal 9 bytes returns null
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Bool_NULL(System.Byte[])">
            <summary>
            Returns bool? from 1-byte array
            if value length != 1 returns null.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Char(System.Byte[])">
            <summary>
            Converts 2 bytes byte[] into Unicode char
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Char_NULL(System.Byte[])">
            <summary>
            Converts 3 bytes byte[] into Unicode char?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_SByte(System.Byte[])">
            <summary>
            Converts 1 byte array into sbyte
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_SByte_NULL(System.Byte[])">
            <summary>
            Converts 2 bytes array into sbyte?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_BigEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in BigEndian order (highest byte first, lowest last) makes short.
            If array not equal 2 bytes throws exception. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_LittleEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in LittleEndian order (lowest byte first, highest last) makes short.
            If array not equal 2 bytes throws exception. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_BigEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in BigEndian order (highest byte first, lowest last) makes short?.
            If array not equal 3 bytes returns null. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in LittleEndian order (lowest byte first, highest last) makes short.
            If array not equal 3 bytes returns null. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_BigEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in BigEndian order (highest byte first, lowest last) makes ushort.
            If array not equal 2 bytes throws exception. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_LittleEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ushort.
            If array not equal 2 bytes throws exception. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_BigEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in BigEndian order (highest byte first, lowest last) makes ushort?.
            If array not equal 3 bytes returns null. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ushort?.
            If array not equal 3 bytes returns null. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_BigEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in BigEndian order (highest byte first, lowest last) makes int.
            If array not equal 4 bytes throws exception. (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_LittleEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in LittleEndian order (lowest byte first, highest last) makes int.
            If array not equal 4 bytes throws exception. (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_BigEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in BigEndian order (highest byte first, lowest last) makes int.
            If array is not equal 5 bytes returns null. Range is (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in LittleEndian order (lowest byte first, highest last) makes int.
            If array not equal 5 bytes returns null. (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_BigEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in BigEndian order (highest byte first, lowest last) makes uint.
            If array not equal 4 bytes throws exception. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_LittleEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in LittleEndian order (lowest byte first, highest last) makes uint.
            If array not equal 4 bytes throws exception. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_BigEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in BigEndian order (highest byte first, lowest last) makes uint?.
            If array not equal 5 bytes returns null. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in LittleEndian order (lowest byte first, highest last) makes uint?.
            If array not equal 5 bytes returns null. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_BigEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in BigEndian order (highest byte first, lowest last) makes long.
            If array not equal 8 bytes throws exception. (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_LittleEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in LittleEndian order (lowest byte first, highest last) makes long.
            If array not equal 8 bytes throws exception. (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_BigEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in BigEndian order (highest byte first, lowest last) makes long.
            If array not equal 9 bytes return null. Range (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in LittleEndian order (lowest byte first, highest last) makes long.
            If array not equal 9 bytes returns null. Range (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.DynamicLength_To_UInt64_BigEndian(System.Byte[])">
            <summary>
            From dynamic byte array (up to 8 bytes) stored in BigEndian format creates ulong value, 
            note if given byte array bigger then 8 bytes - then calcualtion will start from 0
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_BigEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in BigEndian order (highest byte first, lowest last) makes ulong.
            If array not equal 8 bytes throws exception. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_LittleEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ulong.
            If array not equal 8 bytes throws exception. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_BigEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in BigEndian order (highest byte first, lowest last) makes ulong?.
            If array is not equal 9 bytes returns null. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ulong?.
            If array is not equal 9 bytes returns null. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Decimal_BigEndian(System.Byte[])">
            <summary>
            Converts sortable byte[15] to decimal
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Decimal_BigEndian_NULL(System.Byte[])">
            <summary>
            Converts sortable byte[16] to decimal? if byte array lenght is not 16 returns null
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Double_BigEndian(System.Byte[])">
            <summary>
            Converts sortable byte[9] to double
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Double_BigEndian_NULL(System.Byte[])">
            <summary>
            Converts sortable byte[10] to double?
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Float_BigEndian(System.Byte[])">
            <summary>
            Converts sortable byte[4] to float
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Float_BigEndian_NULL(System.Byte[])">
            <summary>
            Converts sortable byte[5] to float?
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_byte_array(System.Nullable{System.Byte})">
            <summary>
            Returns 2 byte array which represents byte?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array(System.DateTime)">
            <summary>
            DateTime to byte[8] big-endian.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_zCompatibility(System.DateTime)">
            <summary>
            DON't use it (only for compatibility resasons described in docu from [20120922])
            DateTime to byte[8] big-endian.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array(System.Nullable{System.DateTime})">
            <summary>
            DateTime? to byte[9] big-endian.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_1_byte_array(System.Nullable{System.Boolean})">
            <summary>
            Returns 1 byte which represents bool?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_byte_array(System.Char)">
            <summary>
            Converts char into byte[2] Unicode representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_byte_array(System.Nullable{System.Char})">
            <summary>
            Converts char? into byte[3] Unicode representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_byte_array(System.Nullable{System.SByte})">
            <summary>
            Converts sbyte? into 2 byte array
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_BigEndian(System.Int16)">
            <summary>
            From Int16 to 2 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_LittleEndian(System.Int16)">
            <summary>
            From Int16 to 2 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_BigEndian(System.Nullable{System.Int16})">
            <summary>
            From Int16? to 3 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_LittleEndian(System.Nullable{System.Int16})">
            <summary>
            From Int16? to 3 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_BigEndian(System.UInt16)">
            <summary>
            From UInt16 to 2 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_LittleEndian(System.UInt16)">
            <summary>
            From UInt16 to 2 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_BigEndian(System.Nullable{System.UInt16})">
            <summary>
            From UInt16? to 3 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_LittleEndian(System.Nullable{System.UInt16})">
            <summary>
            From UInt16? to 3 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_BigEndian(System.Int32)">
            <summary>
            From Int32 to 4 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_LittleEndian(System.Int32)">
            <summary>
            From Int32 to 4 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_BigEndian(System.Nullable{System.Int32})">
            <summary>
            From Int32? to 5 bytes array with BigEndian order (highest byte first, lowest last).   
            When first byte is 0 then the whole value is NULL
            When first byte is 1 then value can be converted
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_LittleEndian(System.Nullable{System.Int32})">
            <summary>
            From Int32 to 4 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_BigEndian(System.UInt32)">
            <summary>
            From UInt32 to 4 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_LittleEndian(System.UInt32)">
            <summary>
            From UInt32 to 4 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_BigEndian(System.Nullable{System.UInt32})">
            <summary>
            From UInt32? to 5 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_LittleEndian(System.Nullable{System.UInt32})">
            <summary>
            From UInt32? to 5 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_BigEndian(System.Int64)">
            <summary>
            From Int64 to 8 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_LittleEndian(System.Int64)">
            <summary>
            From Int64 to 8 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_BigEndian(System.Nullable{System.Int64})">
            <summary>
            From Int64? to 9 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_LittleEndian(System.Nullable{System.Int64})">
            <summary>
            From Int64? to 9 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_BigEndian(System.UInt64)">
            <summary>
            From UInt64 to 8 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_LittleEndian(System.UInt64)">
            <summary>
            From UInt64 to 8 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_BigEndian(System.Nullable{System.UInt64})">
            <summary>
            From UInt64? to 9 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_LittleEndian(System.Nullable{System.UInt64})">
            <summary>
            From UInt64? to 9 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_15_bytes_array_BigEndian(System.Decimal)">
            <summary>
            Converts  decimal to sortable byte[15] 
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_16_bytes_array_BigEndian(System.Nullable{System.Decimal})">
            <summary>
            Converts  decimal? to sortable byte[16] 
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_BigEndian(System.Double)">
            <summary>
            Converts  double to sortable byte[9]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_10_bytes_array_BigEndian(System.Nullable{System.Double})">
            <summary>
            Converts double to sortable byte[10]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_BigEndian(System.Single)">
            <summary>
             Converts float to sortable byte[4]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_BigEndian(System.Nullable{System.Single})">
            <summary>
             Converts float? to sortable byte[5]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.TruncateUTF8(System.String,System.Int32)">
            <summary>
            Truncates UTF-8 strign up to special maxSizeInBytes due to UTF-8 specification. 
            </summary>
            <param name="text"></param>
            <param name="maxSizeInBytes"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_FixedSizeColumn(System.String,System.Int16,System.Boolean)">
            <summary>
            Converts your text into byte[], which can be used as column of fixedSize+2. 
            <para>(2 bytes are always added to your fixedSize value, determination of actual text size and NULL flag)</para>
            <para>String can be null</para>
            Will return byte[] with the lenght fixedSize+2 which can be stored as column.
            <para>If text.Length after convertion (using ASCII or UTF8) overexceeds fixedSize, text will be truncated</para>
            </summary>
            <param name="value">any string, can be NULL</param>
            <param name="fixedSize">reservation space(returned byte[] will be of fixedSize+2)</param>
            <param name="isASCII">if true, text will be presented as ASCII, otherwise as UTF-8</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.From_FixedSizeColumn(System.Byte[],System.Boolean)">
            <summary>
            takes byte[] created by To_FixedSizeColumn and restores string value from it.
            <para>byte[] must be of length fixedSize(which you gave in To_FixedSizeColumn) + 2</para>
            </summary>
            <param name="value"></param>
            <param name="isASCII">if true, text was presented as ASCII, otherwise as UTF-8</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBase64String(System.Byte[])">
            <summary>
            Creates a Base64string from byte array. Good for hashes.
            </summary>
            <param name="dBytes"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytesString(System.Byte[],System.String)">
            <summary>
            Converts BytesArray to String Representation: 00-00-00-00-1F-00-00-00-00-20.
            If array is null or 0 length - returns String.Empty.
            If replaceWith is String.Empty returns such view 00-00-00-00-1F-00-00-00-00-20.
            Otherwise takes such view (-00-00-00-00-1F-00-00-00-00-20) and replaces "-" with replaceWith also calls Trim().      
            </summary>
            <param name="dBytes"></param>
            <param name="replaceWith"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Utils.BytesProcessing._hexDigits">
            <summary>
            Used by ToBytesString
            </summary>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytesString(System.Byte[])">
            <summary>
            To pure HEX string without delimiters
            </summary>
            <param name="dBytes"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToHex(System.Byte)">
            <summary>
            Convert Byte To Hex string
            </summary>
            <param name="dByte"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytesStringDec(System.Byte[],System.String)">
            <summary>
            Converts BytesArray to String Representation: 00-00-00-00-128-12-214-00-00-20.
            Where replaceWith = "-"
            </summary>
            <param name="dBytes"></param>
            <param name="replaceWith"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBitArray(System.Byte)">
            <summary>
            BigEndian
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Get_CRC16_AsByteArray(System.Byte[])">
            <summary>
            Returns byte representation of Crc16
            </summary>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoOneBitUp_NoArrayGrow_BigEndian(System.Byte[])">
            <summary>
            Adds byte[] + 1 bit.
            Returns: had {255}    -> null
            Returns: had {15,255} -> {16,0} 
            Returns: had {15,248} -> {15,249} 
            Returns: bt=null || bt.Length == 0 -> null
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoOneBitUp_ArrayGrows_BigEndian(System.Byte[])">
            <summary>
            Adds + 1 bit
            The same as BytesAction_GoOneBitUp_NoArrayGrow_BigEndian but array grows
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoOneBitDown_NoArrayGrow_BigEndian(System.Byte[])">
            <summary>
            Extracts 1 bit
            Returns: {0} -> null
            Returns: {0,0,0,0} -> null
            Returns: {254} -> {253}
            Returns: {1} -> {0}
            Returns: {121,456} -> {121,455}
            Returns: {121,0} -> {120,255}
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoUpNextByteStart_NoArrayGrow_BigEndian(System.Byte[],System.Int32)">
            <summary>
            <para>BytesAction_GoUpNextByteStart_NoArrayGrow_BigEndian</para>
            <para>Returns: had {255}    -> null</para>
            <para>Returns: had {255, 0} -> null</para>
            <para>Returns: bt=null || bt.Length less then 2  -> null</para>
            <para>Returns: had {254, 0} -> {255, 0}</para>
            <para>Returns: had {120, 115, 147} -> {120, 116, 0}</para>
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:DBreeze.Utils.BytesProcessing.BytesAction_GoDownNextByteStart_NoArrayGrow_BigEndian(System.Byte[],System.Int32)" -->
        <member name="M:DBreeze.Utils.BytesProcessing._Equals(System.Byte[],System.Byte[])">
            <summary>
            <para>USE _ByteArrayEquals</para>
            If both arrays are null, returns true. Checks nulls also. Uses SequenceEqual
            </summary>
            <param name="ar"></param>
            <param name="compareArray"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing._ByteArrayEquals(System.Byte[],System.Byte[])">
            <summary>
            Managed way compares 2 bytes array. Uses for loop and extra checks like null, length before
            </summary>
            <param name="b1"></param>
            <param name="b2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing._ByteArrayEquals_EqualityBrokenIndex(System.Byte[],System.Byte[])">
            <summary>
            Returns index where equality is broken.
            -2 if equal
            -1 if not comparable (null or so)
            </summary>
            <param name="b1"></param>
            <param name="b2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArraySmallerThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArraySmallerOrEqualThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArrayBiggerThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArrayBiggerOrEqualThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Utils.CustomSerializator.Serializator">
            <summary>
            Must be setup to be used together with DbCustomSerializer
            </summary>
        </member>
        <member name="F:DBreeze.Utils.CustomSerializator.Deserializator">
            <summary>
            Must be setup to be used together with DbCustomSerializer
            </summary>
        </member>
        <member name="F:DBreeze.Utils.CustomSerializator.ByteArraySerializator">
            <summary>
            Into byte array serializator can be supplied (Usually Protobuf.NET)
            </summary>
        </member>
        <member name="F:DBreeze.Utils.CustomSerializator.ByteArrayDeSerializator">
            <summary>
            From byte[] deserializator can be used (Usually Protobuf.NET)
            </summary>
        </member>
        <member name="M:DBreeze.Utils.CustomSerializator.SerializeCustom(System.Object)">
            <summary>
            Serializes object to JSON from Microsoft
            </summary>
            <param name="objectForSerialization"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.CustomSerializator.DeserializeCustom``1(System.String)">
            <summary>
            Deserializes object from Microsoft JSON string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.DbReaderWriterLock">
            <summary>
            Wrapper For System.Threading.ReaderWriterLockSlim
            In case if better algorithm will be found
            </summary>
        </member>
        <member name="T:DBreeze.Utils.DbReaderWriterSpinLock">
            <summary>
            Temporar wrapper
            </summary>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.#ctor">
            <summary>
            Creates open Gate
            </summary>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.PutGateHere">
            <summary>
            Sets Gate in the code
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.PutGateHere(System.Int32)">
            <summary>
            If gate is closed then it will be closed timeout time in milliseconds
            </summary>
            <param name="milliseconds"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.PutGateHere(System.Int32,System.Boolean)">
            <summary>
            If gate is closed then it will be closed timeout time in milliseconds
            </summary>
            <param name="milliseconds"></param>
            <param name="milliseconds">exitContext</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Hash.MurMurHash.MixedMurMurHash3_128(System.Byte[])">
            <summary>
            128 bit mixed MurMurhash3
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Hash.MurMurHash.MixedMurMurHash3_64(System.Byte[])">
            <summary>
            64 bit mixed MurMurhash3
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Hash.MurMurHash.MurmurHash3(System.Byte[],System.UInt32)">
            <summary>
            32 bit
            </summary>
            <param name="data"></param>
            <param name="seed"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.XmlSerializator.SerializeXml(System.Object)">
            <summary>
            Serializes object to XML string
            </summary>
            <param name="objectForSerialization"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.XmlSerializator.DeserializeXml``1(System.String)">
            <summary>
            Deserializes object from XML string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <returns></returns>
        </member>
    </members>
</doc>
